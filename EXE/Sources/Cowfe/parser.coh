# %include sections from the grammar
#line 118 "parser.y"

	sub BeginNormalLoop(): (ll: [LoopLabels]) is
		ll := InternalAlloc(@bytesof LoopLabels) as [LoopLabels];
		ll.loop_label := AllocLabel();
		ll.exit_label := AllocLabel();
		ll.old_break_label := break_label;
		ll.old_continue_label := continue_label;
		break_label := ll.exit_label;
		continue_label := ll.loop_label;
	end sub;

	sub TerminateNormalLoop(ll: [LoopLabels]) is
		Generate(MidJump(continue_label));
		Generate(MidLabel(break_label));
		break_label := ll.old_break_label;
		continue_label := ll.old_continue_label;
		Free(ll as [uint8]);
	end sub;
#line 318 "parser.y"

	sub Negate(node: [Node]) is
		node.beq.negated := node.beq.negated ^ 1;
	end sub;
#line 341 "parser.y"

	sub ConditionalEq(lhs: [Node], rhs: [Node], negated: uint8): (result: [Node]) is
		CondSimple(lhs, rhs);
		var truelabel := AllocLabel();
		var falselabel := AllocLabel();
		var w := NodeWidth(lhs);

		result := MidBeq(w, lhs, rhs, truelabel, falselabel, 0, negated);
	end sub;

	sub ConditionalLt(lhs: [Node], rhs: [Node], negated: uint8): (result: [Node]) is
		CondSimple(lhs, rhs);
		var truelabel := AllocLabel();
		var falselabel := AllocLabel();
		var w := NodeWidth(lhs);

		if IsSNum(lhs.type) != 0 then
			result := MidBlts(w, lhs, rhs, truelabel, falselabel, 0, negated);
		else
			result := MidBltu(w, lhs, rhs, truelabel, falselabel, 0, negated);
		end if;
	end sub;
#line 449 "parser.y"

	sub parser_i_bad_next_prev() is
		SimpleError("@next and @prev only work on pointers");
	end sub;
#line 627 "parser.y"

	sub parser_i_constant_error() is
		SimpleError("only constant values are allowed here");
	end sub;
#line 776 "parser.y"

	sub i_check_sub_call_args() is
		var subr := current_call.intfsubr;
		if current_call.num_input_args != subr.num_input_parameters then
			StartError();
			print("subroutine ");
			print(subr.symbol.name);
			print(" takes ");
			print_i8(subr.num_input_parameters);
			print(" but was given ");
			print_i8(current_call.num_input_args);
			EndError();
		end if;
	end sub;

	sub i_end_call() is
		EmitterReferenceSubroutine(current_subr, current_call.intfsubr);
		var call := current_call;
		current_call := call.parent;
		Free(call as [uint8]);
	end sub;
#line 986 "parser.y"

	var preparing_subr: [Subroutine];
#line 1187 "parser.y"

	sub SymbolRedeclarationError() is
		StartError();
		print("attempt to redefine ");
		print(current_type.symbol.name);
		EndError();
	end sub;
#line 1277 "parser.y"

	var current_member: [Symbol];    # for records only
	var current_offset: Size;        # within the current braced element
	var current_global_offset: Size; # overall

	record NestedTypeInit is
		old_current_type: [Type];
		old_current_member: [Symbol];
		old_current_offset: Size;
	end record;

	sub WrongNumberOfElementsError() is
		StartError();
		print("wrong number of elements in initialiser for ");
		print(current_type.symbol.name);
		EndError();
	end sub;

	sub CheckEndOfInitialiser() is
		if IsArray(current_type) != 0 then
			var memberwidth := current_type.arraytype.element.stride;
			current_offset := ArchAlignUp(current_offset, current_type.arraytype.element.alignment);
			if current_type.width == 0 then
				current_type.width := current_offset;
				var size := current_offset / memberwidth;
				current_type.arraytype.size := size;
				current_type.arraytype.indextype := ArchGuessIntType(0, (size-1) as Arith);
			end if;
			if current_offset != current_type.width then
				WrongNumberOfElementsError();
			end if;
		else
			if current_member != (0 as [Symbol]) then
				WrongNumberOfElementsError();
			end if;
		end if;
	end sub;

	sub GetInitedMember(): (member: [Symbol], type: [Type]) is
		member := 0 as [Symbol];

		if IsArray(current_type) != 0 then
			type := current_type.arraytype.element;
		else
			if current_member == (0 as [Symbol]) then
				type := 0 as [Type];
				return;
			end if;

			member := current_member;
			type := current_member.vardata.type;
			current_member := current_member.next;
		end if;
	end sub;

	sub AlignTo(alignment: uint8) is
		var newoffset := ArchAlignUp(current_global_offset, alignment);
		while current_global_offset != newoffset loop
			Generate(MidInit(1, 0));
			current_offset := current_offset + 1;
			current_global_offset := current_global_offset + 1;
		end loop;
	end sub;

	sub CheckForOverlaps(member: [Symbol]) is
		# Not for arrays.
		if member == (0 as [Symbol]) then
			return;
		end if;

		if member.vardata.offset < current_offset then
			SimpleError("out of order static initialisation");
		end if;
	end sub;

	sub GetInitedMemberChecked(): (member: [Symbol], type: [Type]) is
		(member, type) := GetInitedMember();
		if type == (0 as [Type]) then
			WrongNumberOfElementsError();
		end if;

		AlignTo(type.alignment);
		CheckForOverlaps(member);
	end sub;
#line 178 "parser.coh"

# makeheaders token definitions

# control settings
typedef YYCODETYPE is uint8;
const YYNOCODE := 125;
typedef YYACTIONTYPE is uint16;
typedef ParseTOKENTYPE is Token;
record YYMINORTYPE is
  yy0 @at(0): ParseTOKENTYPE;
  yy25 @at(0): [Type];
  yy54 @at(0): Size;
  yy124 @at(0): [LoopLabels];
  yy140 @at(0): [NestedTypeInit];
  yy161 @at(0): [Node];
  yy191 @at(0): Arith;
  yy237 @at(0): [Symbol];
end record;
const YYSTACKDEPTH := 100;
const YYNSTATE             := 221;
const YYNRULE              := 141;
const YYNTOKEN             := 70;
const YY_MAX_SHIFT         := 220;
const YY_MIN_SHIFTREDUCE   := 312;
const YY_MAX_SHIFTREDUCE   := 452;
const YY_ERROR_ACTION      := 453;
const YY_ACCEPT_ACTION     := 454;
const YY_NO_ACTION         := 455;
const YY_MIN_REDUCE        := 456;
const YY_MAX_REDUCE        := 596;
const YY_MAX_RHS_SYMBOLS   := 8;

record yyStackEntry is
	stateno: YYACTIONTYPE;
	major: YYCODETYPE;
	minor: YYMINORTYPE;
end record;

var yytos: [yyStackEntry];
var yystack: yyStackEntry[YYSTACKDEPTH+1];
var yyerrcnt: int8;

# parsing tables
const YY_ACTTAB_COUNT := 1291;
var yy_action: YYACTIONTYPE[YY_ACTTAB_COUNT] := {
  533,  427,  511,  208,   94,  454,    8,   96,  104,  328,
  186,  185,  110,  318,   55,  175,   17,   40,  574,  385,
   82,  220,  434,   77,  105,   86,  574,   53,   98,  320,
  187,  552,   24,  382,  344,   73,   81,  329,  217,  197,
   80,  371,  180,  191,   83,  346,  420,   45,   51,  596,
  168,  383,  167,   52,   54,  114,  215,  169,  168,  479,
   44,   42,   41,  409,  207,   31,  172,  427,  216,  208,
  219,  519,  511,   96,   97,  334,  179,  150,  110,  318,
   55,   79,   17,   40,   77,  519,   82,  220,  434,   75,
   49,   86,  184,   53,   98,  320,  519,  114,  132,  382,
  344,  147,   81,  164,  174,  197,   80,  371,  180,  191,
   83,  346,  219,  219,  511,  511,   97,   97,   22,   20,
  156,  536,  183,   59,  382,  429,   44,   42,   41,  190,
  207,   31,  428,  427,  216,  208,  153,   68,   24,   96,
  399,  519,  210,  313,  110,  318,   55,  190,   17,   40,
  203,  155,   82,  220,  434,  519,  383,   86,  441,   53,
   98,  320,   69,  114,  115,  382,  344,  147,   81,  206,
  519,  197,   80,  371,  180,  191,   83,  346,  219,  219,
  511,  511,   97,   97,  591,   64,   88,  114,  201,  540,
  154,  481,   44,   42,   41,  381,  207,   31,  218,  427,
  216,  208,  219,  146,  511,   96,   97,   18,  211,  519,
  110,  318,   55,   74,   17,   40,   24,  519,   82,  220,
  434,  417,  519,   86,  190,   53,   98,  320,  559,  124,
  382,  382,  344,  184,   81,  133,  217,  197,   80,  371,
  180,  191,   83,  346,  219,   45,  511,   89,   97,  166,
  219,  178,  511,  113,   97,  582,  106,  144,   44,   42,
   41,  547,  207,   31,  575,  427,  216,  208,  219,  390,
  511,   96,   97,  148,  148,   11,  110,  318,   55,  404,
   17,   40,  523,  528,   82,  220,  434,   75,   49,   86,
   39,   53,   98,  320,   76,  124,  382,  382,  344,  424,
   81,  133,  546,  197,   80,  371,  180,  191,   83,  346,
  219,   29,  511,   14,   97,  212,  219,  404,  511,  114,
   97,  510,  528,  209,   44,   42,   41,  100,  207,   31,
   66,  427,  216,  208,  219,  102,  511,   96,   97,  149,
  149,   11,  110,  318,   55,  551,   17,   40,  509,  528,
   82,  220,  434,  170,  321,   86,   16,   53,   98,  320,
    1,  114,  124,  382,  344,  145,   81,   14,  133,  197,
   80,  371,  180,  191,   83,  346,  219,  219,  511,  511,
   97,   97,  173,  219,  116,  511,  193,   97,   22,   20,
   44,   42,   41,  199,  207,   31,  345,  195,  216,  219,
  217,  511,  132,   97,  556,  185,   56,  593,   11,   45,
   51,   58,  177,   64,   88,   52,   54,  219,  217,  511,
  376,   97,   22,   20,   56,  537,  530,   45,   51,   58,
   24,  101,   24,   52,   54,  380,  163,  187,  552,  133,
    3,   48,   50,   35,   32,   33,   34,   37,   36,   47,
   46,   75,   49,  198,  219,  151,  511,  546,   97,   48,
   50,   35,   32,   33,   34,   37,   36,   47,   46,   75,
   49,  577,  103,    4,  118,  112,  111,   23,  187,  552,
  152,  580,  108,   13,  107,   67,   87,  217,    5,  219,
    9,  511,   78,   95,   10,  194,   45,   99,  217,    2,
   15,  133,    6,    7,   56,   92,   91,   45,   51,   58,
  333,   24,  546,   52,   54,  214,  219,  171,  511,  577,
   97,   62,  118,  112,  111,   23,  332,   61,   12,  205,
  108,   13,  107,  426,   57,   40,  421,  219,  419,  511,
   63,   95,  577,  194,   25,  118,  112,  111,   23,   75,
   49,  382,  344,   92,   91,  107,   70,  414,  176,  371,
  219,   65,  511,  346,   95,  171,  194,  405,   90,   62,
   71,  443,   84,  442,   93,  181,   92,   91,  577,  401,
  125,  118,  112,  111,   23,  410,  188,  189,  171,  440,
   85,  107,   62,   60,  388,  219,  219,  511,  511,   97,
   95,   72,  194,  577,  387,  200,  118,  112,  111,   23,
  196,  182,   92,   91,  373,  133,  107,   26,  395,   27,
  330,  219,  202,  511,  171,   95,  204,  194,   62,  213,
  219,  126,  511,  324,   97,  109,  192,   92,   91,   55,
  323,   57,   40,   20,  322,  127,  219,  319,  511,  171,
   97,  317,   53,   62,  128,  377,  425,  374,  382,  344,
  219,   81,  511,   28,   97,   80,  371,   30,   43,  219,
  346,  511,  370,   97,  533,  129,   55,   19,   21,   40,
  455,  312,  130,  455,  455,   44,   42,   41,  455,   53,
  219,  455,  511,  216,   97,  382,  344,  219,   81,  511,
  455,   97,   80,  371,  455,  455,  455,  346,  391,  455,
  131,  455,  455,  455,  455,  455,  455,  117,   55,  455,
   57,   40,   44,   42,   41,  219,  455,  511,  455,   97,
  216,   53,  219,  455,  511,  455,   97,  382,  344,  455,
   81,  455,  455,  455,   80,  371,  455,  455,  455,  346,
  165,  455,  119,  455,  455,   55,  455,   57,   40,  455,
  455,  120,  455,  455,   44,   42,   41,  219,   53,  511,
  157,   97,  216,  455,  382,  344,  219,   81,  511,  455,
   97,   80,  371,  378,  455,  219,  346,  511,  455,   97,
  455,  455,   55,  455,   57,   40,  455,  455,  158,  455,
  455,   44,   42,   41,  455,   53,  455,  159,  455,  216,
  160,  382,  344,  219,   81,  511,  455,   97,   80,  371,
  455,  455,  219,  346,  511,  219,   97,  511,  455,   97,
  577,  455,  455,  118,  112,  111,   23,  455,   44,   42,
   41,  455,  455,  107,  121,  455,  216,  455,  219,  455,
  511,  455,   95,  455,  194,   55,  455,   57,   40,  219,
  455,  511,  455,   97,   92,   91,  455,  455,   53,  455,
  455,  455,  455,  455,  382,  344,  171,   81,  455,  345,
   62,   80,  371,  217,  455,  455,  346,  455,  455,   56,
  455,  136,   45,   51,   58,  455,  455,  455,   52,   54,
  455,   44,   42,   41,  455,  455,  219,  217,  511,  216,
   97,  137,  455,   56,  455,  455,   45,   51,   58,  455,
  455,  455,   52,   54,   48,   50,  219,  455,  511,  455,
   97,  217,   47,   46,   75,   49,  455,   56,  455,  455,
   45,   51,   58,  455,  455,  316,   52,   54,   48,   50,
  455,  134,  161,  455,  455,  455,   47,   46,   75,   49,
  455,  455,  455,  455,  455,  331,  219,  219,  511,  511,
   97,   97,   48,   50,  455,  455,  455,  455,  135,  455,
   47,   46,   75,   49,   38,  455,  455,  455,  455,  455,
  217,  455,  142,  219,  455,  511,   56,   97,  455,   45,
   51,   58,  455,  455,  455,   52,   54,  219,  217,  511,
  143,   97,  455,  455,   56,  455,  455,   45,   51,   58,
  455,  455,  315,   52,   54,  219,  455,  511,  162,   97,
  455,   48,   50,  455,  455,  455,  455,  455,  455,   47,
   46,   75,   49,  219,  455,  511,  455,   97,  455,   48,
   50,  455,  455,  455,  141,  455,  455,   47,   46,   75,
   49,  455,  455,  368,  455,  455,  217,  455,  455,  219,
  455,  511,   56,   97,  455,   45,   51,   58,  455,  455,
  455,   52,   54,  369,  455,  455,  217,  455,  455,  455,
  455,  455,   56,  455,  140,   45,   51,   58,  455,  455,
  455,   52,   54,  455,  139,  122,  455,   48,   50,  219,
  455,  511,  455,   97,  455,   47,   46,   75,   49,  219,
  219,  511,  511,   97,   97,  455,  138,   48,   50,  455,
  455,  455,  455,  455,  455,   47,   46,   75,   49,  455,
  455,  219,  455,  511,  217,   97,  455,  455,  123,  455,
   56,  455,  455,   45,   51,   58,  455,  455,  314,   52,
   54,  455,  217,  219,  455,  511,  455,   97,   56,  455,
  455,   45,   51,   58,  455,  455,  455,   52,   54,  455,
  455,  455,  455,  455,  455,   48,   50,  455,  455,  455,
  455,  455,  455,   47,   46,   75,   49,  455,  455,  455,
  455,  455,  455,   48,   50,  455,  455,  455,  455,  455,
  455,   47,   46,   75,   49,  455,  455,  455,  455,  455,
  217,  455,  455,  455,  455,  455,   56,  455,  455,   45,
   51,   58,  455,  455,  455,   52,   54,  455,  217,  455,
  455,  455,  455,  455,   56,  455,  455,   45,   51,   58,
  455,  455,  455,   52,   54,  455,  455,  455,  455,  455,
  455,  455,   50,  455,  455,  455,  455,  455,  455,   47,
   46,   75,   49,  455,  455,  455,  455,  455,  455,  455,
  455,  455,  455,  455,  455,  455,  455,   47,   46,   75,
   49,
};
var yy_lookahead: YYCODETYPE[] := {
   90,    1,   92,    3,   94,   70,   71,    7,  104,    9,
  110,  111,   12,   13,   14,  117,   16,   17,   92,    4,
   20,   21,   22,   16,  102,   25,   92,   27,   28,   29,
  108,  109,   17,   33,   34,   17,   36,   37,    8,   39,
   40,   41,   42,   43,   44,   45,   33,   17,   18,  123,
  124,   33,   74,   23,   24,   75,   38,  123,  124,   79,
   60,   61,   62,    4,   64,   65,   74,    1,   68,    3,
   90,   93,   92,    7,   94,    4,   10,   74,   12,   13,
   14,   63,   16,   17,   16,   93,   20,   21,   22,   59,
   60,   25,   33,   27,   28,   29,   93,   75,   75,   33,
   34,   79,   36,   81,   35,   39,   40,   41,   42,   43,
   44,   45,   90,   90,   92,   92,   94,   94,   47,   48,
   97,   98,   74,    2,   33,   34,   60,   61,   62,   11,
   64,   65,   41,    1,   68,    3,   74,   69,   17,    7,
   22,   93,   10,   22,   12,   13,   14,   11,   16,   17,
   10,   74,   20,   21,   22,   93,   33,   25,   22,   27,
   28,   29,    6,   75,   75,   33,   34,   79,   36,   81,
   93,   39,   40,   41,   42,   43,   44,   45,   90,   90,
   92,   92,   94,   94,  114,  115,  116,   75,   99,  100,
   74,   79,   60,   61,   62,   33,   64,   65,   74,    1,
   68,    3,   90,   74,   92,    7,   94,   67,   10,   93,
   12,   13,   14,   16,   16,   17,   17,   93,   20,   21,
   22,   22,   93,   25,   11,   27,   28,   29,   93,   75,
   33,   33,   34,   33,   36,   75,    8,   39,   40,   41,
   42,   43,   44,   45,   90,   17,   92,  112,   94,   89,
   90,  113,   92,   75,   94,   87,   88,   79,   60,   61,
   62,   92,   64,   65,    0,    1,   68,    3,   90,    4,
   92,    7,   94,  119,  120,  121,   12,   13,   14,   66,
   16,   17,   91,   92,   20,   21,   22,   59,   60,   25,
    2,   27,   28,   29,    6,   75,   33,   33,   34,   32,
   36,   75,   73,   39,   40,   41,   42,   43,   44,   45,
   90,   46,   92,   46,   94,   89,   90,   66,   92,   75,
   94,   91,   92,   79,   60,   61,   62,  104,   64,   65,
  101,    1,   68,    3,   90,  104,   92,    7,   94,  119,
  120,  121,   12,   13,   14,  109,   16,   17,   91,   92,
   20,   21,   22,   32,   13,   25,   16,   27,   28,   29,
   71,   75,   75,   33,   34,   79,   36,   46,   75,   39,
   40,   41,   42,   43,   44,   45,   90,   90,   92,   92,
   94,   94,   89,   90,   75,   92,   95,   94,   47,   48,
   60,   61,   62,   73,   64,   65,    4,   95,   68,   90,
    8,   92,   75,   94,  110,  111,   14,  120,  121,   17,
   18,   19,  114,  115,  116,   23,   24,   90,    8,   92,
    5,   94,   47,   48,   14,   98,   95,   17,   18,   19,
   17,  102,   17,   23,   24,   22,   73,  108,  109,   75,
   71,   49,   50,   51,   52,   53,   54,   55,   56,   57,
   58,   59,   60,   89,   90,  103,   92,   73,   94,   49,
   50,   51,   52,   53,   54,   55,   56,   57,   58,   59,
   60,   72,  102,   71,   75,   76,   77,   78,  108,  109,
  103,   82,   83,   84,   85,  101,  103,    8,   71,   90,
   71,   92,   86,   94,   71,   96,   17,   26,    8,   71,
   80,   75,   71,   71,   14,  106,  107,   17,   18,   19,
    6,   17,   73,   23,   24,   89,   90,  118,   92,   72,
   94,  122,   75,   76,   77,   78,    6,   46,   31,   82,
   83,   84,   85,   22,   16,   17,   22,   90,    4,   92,
  101,   94,   72,   96,   16,   75,   76,   77,   78,   59,
   60,   33,   34,  106,  107,   85,    6,   20,   10,   41,
   90,   66,   92,   45,   94,  118,   96,   25,   25,  122,
    6,   22,   46,   22,    6,  105,  106,  107,   72,    4,
   75,   75,   76,   77,   78,    4,   41,   16,  118,   22,
   25,   85,  122,    2,   22,   90,   90,   92,   92,   94,
   94,   66,   96,   72,   22,  100,   75,   76,   77,   78,
   33,  105,  106,  107,   22,   75,   85,    2,    4,   46,
   22,   90,   65,   92,  118,   94,   10,   96,  122,   89,
   90,   75,   92,   12,   94,   26,  105,  106,  107,   14,
   22,   16,   17,   48,   22,   75,   90,   13,   92,  118,
   94,   13,   27,  122,   75,    5,   31,    4,   33,   34,
   90,   36,   92,   46,   94,   40,   41,   16,   60,   90,
   45,   92,   33,   94,   16,   75,   14,   15,   16,   17,
  125,   22,   75,  125,  125,   60,   61,   62,  125,   27,
   90,  125,   92,   68,   94,   33,   34,   90,   36,   92,
  125,   94,   40,   41,  125,  125,  125,   45,    4,  125,
   75,  125,  125,  125,  125,  125,  125,   75,   14,  125,
   16,   17,   60,   61,   62,   90,  125,   92,  125,   94,
   68,   27,   90,  125,   92,  125,   94,   33,   34,  125,
   36,  125,  125,  125,   40,   41,  125,  125,  125,   45,
    9,  125,   75,  125,  125,   14,  125,   16,   17,  125,
  125,   75,  125,  125,   60,   61,   62,   90,   27,   92,
   75,   94,   68,  125,   33,   34,   90,   36,   92,  125,
   94,   40,   41,    5,  125,   90,   45,   92,  125,   94,
  125,  125,   14,  125,   16,   17,  125,  125,   75,  125,
  125,   60,   61,   62,  125,   27,  125,   75,  125,   68,
   75,   33,   34,   90,   36,   92,  125,   94,   40,   41,
  125,  125,   90,   45,   92,   90,   94,   92,  125,   94,
   72,  125,  125,   75,   76,   77,   78,  125,   60,   61,
   62,  125,  125,   85,   75,  125,   68,  125,   90,  125,
   92,  125,   94,  125,   96,   14,  125,   16,   17,   90,
  125,   92,  125,   94,  106,  107,  125,  125,   27,  125,
  125,  125,  125,  125,   33,   34,  118,   36,  125,    4,
  122,   40,   41,    8,  125,  125,   45,  125,  125,   14,
  125,   75,   17,   18,   19,  125,  125,  125,   23,   24,
  125,   60,   61,   62,  125,  125,   90,    8,   92,   68,
   94,   75,  125,   14,  125,  125,   17,   18,   19,  125,
  125,  125,   23,   24,   49,   50,   90,  125,   92,  125,
   94,    8,   57,   58,   59,   60,  125,   14,  125,  125,
   17,   18,   19,  125,  125,   22,   23,   24,   49,   50,
  125,   75,   75,  125,  125,  125,   57,   58,   59,   60,
  125,  125,  125,  125,  125,   66,   90,   90,   92,   92,
   94,   94,   49,   50,  125,  125,  125,  125,   75,  125,
   57,   58,   59,   60,    2,  125,  125,  125,  125,  125,
    8,  125,   75,   90,  125,   92,   14,   94,  125,   17,
   18,   19,  125,  125,  125,   23,   24,   90,    8,   92,
   75,   94,  125,  125,   14,  125,  125,   17,   18,   19,
  125,  125,   22,   23,   24,   90,  125,   92,   75,   94,
  125,   49,   50,  125,  125,  125,  125,  125,  125,   57,
   58,   59,   60,   90,  125,   92,  125,   94,  125,   49,
   50,  125,  125,  125,   75,  125,  125,   57,   58,   59,
   60,  125,  125,    5,  125,  125,    8,  125,  125,   90,
  125,   92,   14,   94,  125,   17,   18,   19,  125,  125,
  125,   23,   24,    5,  125,  125,    8,  125,  125,  125,
  125,  125,   14,  125,   75,   17,   18,   19,  125,  125,
  125,   23,   24,  125,   75,   75,  125,   49,   50,   90,
  125,   92,  125,   94,  125,   57,   58,   59,   60,   90,
   90,   92,   92,   94,   94,  125,   75,   49,   50,  125,
  125,  125,  125,  125,  125,   57,   58,   59,   60,  125,
  125,   90,  125,   92,    8,   94,  125,  125,   75,  125,
   14,  125,  125,   17,   18,   19,  125,  125,   22,   23,
   24,  125,    8,   90,  125,   92,  125,   94,   14,  125,
  125,   17,   18,   19,  125,  125,  125,   23,   24,  125,
  125,  125,  125,  125,  125,   49,   50,  125,  125,  125,
  125,  125,  125,   57,   58,   59,   60,  125,  125,  125,
  125,  125,  125,   49,   50,  125,  125,  125,  125,  125,
  125,   57,   58,   59,   60,  125,  125,  125,  125,  125,
    8,  125,  125,  125,  125,  125,   14,  125,  125,   17,
   18,   19,  125,  125,  125,   23,   24,  125,    8,  125,
  125,  125,  125,  125,   14,  125,  125,   17,   18,   19,
  125,  125,  125,   23,   24,  125,  125,  125,  125,  125,
  125,  125,   50,  125,  125,  125,  125,  125,  125,   57,
   58,   59,   60,  125,  125,  125,  125,  125,  125,  125,
  125,  125,  125,  125,  125,  125,  125,   57,   58,   59,
   60,  125,  125,  125,  125,  125,  125,  125,  125,  125,
  125,  125,  125,  125,  125,  125,  125,  125,  125,   70,
   70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
   70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
   70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
   70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
   70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
   70,
};
const YY_SHIFT_COUNT    := 220;
const YY_SHIFT_MIN      := 0;
const YY_SHIFT_MAX      := 1230;
typedef YYTOKENOFFSETTYPE is uint16;
var yy_shift_ofst: YYTOKENOFFSETTYPE[] := {
 1291,    0,    0,   66,   66,   66,  132,  198,  264,  330,
  330,  625,  625,  662,  625,  662,  704,  841,  741,  662,
  662,  662,  662,  662,  778,  841,  841,  841,  841,  841,
  841,  841,  841,  841,  841,  841,  841,  841,  841,  841,
  841,  841,  841,  841,  841,  841,  841,  841,  841,  841,
  841,  841,  841,  841,  841,  841,  841,  841,  841,  841,
  518,   91,   91,   68,   13,   13,    7,    7,   18,   18,
   18,   18,   18,   18,   18,   18,   18,   59,  140,  197,
  197,  197,  123,  162,  200,  162,  162,  213,   69,  156,
  263,  251,  251,    7,  340,  340,  162,  340,  162, 1291,
 1291, 1291, 1291, 1291, 1291, 1291, 1291, 1291, 1291, 1291,
 1291, 1291, 1291,  392,  410,  875,  899,  923,  982, 1000,
 1058, 1078,  875, 1136, 1154, 1154, 1154, 1154, 1154, 1154,
 1154, 1154, 1154, 1154, 1212, 1230,  490,  490,   30,   30,
   30,  228,  228,  228,   71,  341,  121,  375,  267,  321,
  199,  118,  136,  413,   15,  415,  265,  479,  479,  479,
  479,  479,  479,  288,  471,  504,  520,  494,  481,  511,
  514,  497,  494,  534,  528,  550,  537,  548,  495,  542,
  543,  549,  551,  494,  564,  526,  581,  568,  575,  545,
  571,  565,  567,  572,  591,  582,  535,  577,  592,  615,
  614,  573,  598,  557,  621,  616,  609,  618,  622,  595,
  634,  638,  650,  653,  617,  651,  608,  639,  494,  658,
  659,
};
const YY_REDUCE_COUNT := 112;
const YY_REDUCE_MIN   := -102;
const YY_REDUCE_MAX   := 1073;
var yy_reduce_ofst: int16[] := {
  -65,  399,  447,  470,  506,  531,  758,  758,  758,  758,
  758,  154,  220,   22,  287,   88,   23,   89,  160,  -20,
  112,  178,  244,  286,  226,  293,  364,  505,  540,  327,
  426,  309,  556,  570,  579,  600,  607,  635,  642,  677,
  686,  695,  723,  732,  735,  769,  816,  836,  876,  877,
  903,  917,  935,  953,  979, 1019, 1029, 1030, 1051, 1073,
  -90,  -74,  -66,  -78,   70,  298,  329,  370,  -22,   -8,
    3,   48,   62,   77,  116,  124,  129, -100,  168,  191,
  230,  257,  135,  229,  294,  384,  439,  -96, -102,  138,
  169,  223,  231,  236,  291,  302,  320,  331,  363,  289,
  369,  352,  402,  377,  417,  383,  419,  406,  423,  428,
  420,  431,  432,
};
var yy_default: YYACTIONTYPE[YYNSTATE] := {
  576,  471,  471,  453,  453,  453,  453,  453,  453,  583,
  579,  594,  594,  453,  594,  453,  453,  453,  453,  453,
  453,  453,  453,  453,  453,  453,  453,  453,  453,  453,
  453,  453,  453,  453,  453,  453,  453,  453,  453,  453,
  453,  453,  453,  453,  453,  453,  453,  453,  453,  453,
  453,  453,  453,  453,  453,  453,  453,  453,  453,  566,
  453,  453,  453,  453,  590,  590,  453,  453,  453,  453,
  453,  453,  453,  453,  453,  453,  453,  453,  453,  453,
  453,  453,  453,  453,  453,  453,  453,  453,  562,  589,
  453,  453,  453,  453,  453,  453,  453,  453,  453,  576,
  576,  588,  576,  588,  576,  588,  576,  581,  576,  576,
  469,  576,  576,  453,  453,  542,  453,  453,  453,  453,
  453,  453,  453,  453,  567,  542,  487,  486,  485,  484,
  483,  482,  538,  516,  501,  499,  503,  502,  494,  495,
  492,  496,  498,  497,  453,  453,  453,  470,  453,  453,
  453,  453,  453,  453,  453,  453,  453,  508,  507,  506,
  505,  500,  493,  453,  453,  453,  453,  544,  595,  453,
  453,  453,  560,  453,  453,  453,  453,  453,  453,  453,
  453,  453,  453,  557,  453,  555,  453,  550,  453,  453,
  453,  453,  453,  453,  453,  530,  453,  453,  453,  453,
  541,  453,  453,  453,  453,  453,  453,  453,  453,  480,
  453,  453,  453,  453,  453,  453,  453,  453,  504,  491,
  453,
};

# fallback rules

# token names
var yyTokenName: [uint8][] := { 
  "$", # 0
  "ASM", # 1
  "ASSIGN", # 2
  "BREAK", # 3
  "CLOSEPAREN", # 4
  "CLOSESQ", # 5
  "COLON", # 6
  "CONST", # 7
  "DOT", # 8
  "ELSE", # 9
  "END", # 10
  "EXTERN", # 11
  "IF", # 12
  "LOOP", # 13
  "MINUS", # 14
  "NOT", # 15
  "OPENPAREN", # 16
  "OPENSQ", # 17
  "PERCENT", # 18
  "PLUS", # 19
  "RECORD", # 20
  "RETURN", # 21
  "SEMICOLON", # 22
  "SLASH", # 23
  "STAR", # 24
  "SUB", # 25
  "THEN", # 26
  "TILDE", # 27
  "VAR", # 28
  "WHILE", # 29
  "TYPE", # 30
  "OPENBR", # 31
  "CLOSEBR", # 32
  "ID", # 33
  "NUMBER", # 34
  "AT", # 35
  "BYTESOF", # 36
  "ELSEIF", # 37
  "INT", # 38
  "TYPEDEF", # 39
  "SIZEOF", # 40
  "STRING", # 41
  "IMPL", # 42
  "DECL", # 43
  "INTERFACE", # 44
  "NIL", # 45
  "COMMA", # 46
  "AND", # 47
  "OR", # 48
  "PIPE", # 49
  "CARET", # 50
  "LTOP", # 51
  "LEOP", # 52
  "GTOP", # 53
  "GEOP", # 54
  "EQOP", # 55
  "NEOP", # 56
  "LSHIFT", # 57
  "RSHIFT", # 58
  "AS", # 59
  "AMPERSAND", # 60
  "NEXT", # 61
  "PREV", # 62
  "INDEXOF", # 63
  "CONTINUE", # 64
  "CASE", # 65
  "IS", # 66
  "WHEN", # 67
  "ALIAS", # 68
  "IMPLEMENTS", # 69
};

# rule names
#var yyRuleName: [uint8][YYNRULE] := {
#};

# destructors
sub yy_destructor(yymajor: YYCODETYPE, yypminor: [YYMINORTYPE]) is
sub token_destructor() is
#line 47 "parser.y"

	if (yymajor == STRING) or (yymajor == ID) then
		print("free unused string\n");
		Free(yypminor.yy0.string as [uint8]);
	end if;

#line 655 "parser.coh"
end sub;
if (yymajor != 0) and (yymajor < YYNTOKEN)
  then token_destructor();
end if;
end sub;

# stack overflow code

sub yy_pop_parser_stack() is
	yytos := @prev yytos;
	yy_destructor(yytos.major, &yytos.minor);
end sub;

sub yy_pop_all_parser_stack() is
	while yytos != &yystack[0] loop
		yy_pop_parser_stack();
	end loop;
end sub;

sub yy_stack_overflow() is
	yy_pop_all_parser_stack();
#line 40 "parser.y"

	StartError();
	print("parser stack overflow");
	EndError();
#line 682 "parser.coh"
end sub;

# For rule J, yyRuleInfoLhs[J] contains the symbol on the left-hand side
# of that rule
var yyRuleInfoLhs: YYCODETYPE[] := {
    72,  # (0) statement ::= RETURN SEMICOLON
    72,  # (1) statement ::= VAR newid COLON typeref SEMICOLON
    72,  # (2) statement ::= VAR newid COLON typeref ASSIGN expression SEMICOLON
    72,  # (3) statement ::= VAR newid ASSIGN expression SEMICOLON
    72,  # (4) statement ::= expression ASSIGN expression SEMICOLON
    72,  # (5) statement ::= startloopstatement statements END LOOP
    76,  # (6) startloopstatement ::= LOOP
    72,  # (7) statement ::= startwhilestatement statements END LOOP
    78,  # (8) initwhilestatement ::= WHILE
    77,  # (9) startwhilestatement ::= initwhilestatement conditional LOOP
    72,  # (10) statement ::= BREAK SEMICOLON
    72,  # (11) statement ::= CONTINUE SEMICOLON
    72,  # (12) statement ::= IF if_begin if_conditional THEN statements if_optional_else END IF
    80,  # (13) if_begin ::=
    81,  # (14) if_conditional ::= conditional
    82,  # (15) if_optional_else ::=
    83,  # (16) if_else ::= ELSE
    84,  # (17) if_elseif ::= ELSEIF
    72,  # (18) statement ::= startcase whens END CASE SEMICOLON
    85,  # (19) startcase ::= CASE expression IS
    88,  # (20) beginwhen ::= WHEN cvalue COLON
    88,  # (21) beginwhen ::= WHEN ELSE COLON
    79,  # (22) conditional ::= OPENPAREN conditional CLOSEPAREN
    79,  # (23) conditional ::= NOT conditional
    79,  # (24) conditional ::= conditional AND conditional
    79,  # (25) conditional ::= conditional OR conditional
    79,  # (26) conditional ::= expression EQOP expression
    79,  # (27) conditional ::= expression NEOP expression
    79,  # (28) conditional ::= expression LTOP expression
    79,  # (29) conditional ::= expression GEOP expression
    79,  # (30) conditional ::= expression GTOP expression
    79,  # (31) conditional ::= expression LEOP expression
    90,  # (32) leafexpression ::= NUMBER
    90,  # (33) leafexpression ::= OPENPAREN expression CLOSEPAREN
    90,  # (34) leafexpression ::= NIL
    75,  # (35) expression ::= leafexpression
    75,  # (36) expression ::= MINUS expression
    75,  # (37) expression ::= TILDE expression
    75,  # (38) expression ::= expression PLUS expression
    75,  # (39) expression ::= expression MINUS expression
    75,  # (40) expression ::= expression STAR expression
    75,  # (41) expression ::= expression SLASH expression
    75,  # (42) expression ::= expression PERCENT expression
    75,  # (43) expression ::= expression CARET expression
    75,  # (44) expression ::= expression AMPERSAND expression
    75,  # (45) expression ::= expression PIPE expression
    75,  # (46) expression ::= expression LSHIFT expression
    75,  # (47) expression ::= expression RSHIFT expression
    75,  # (48) expression ::= expression AS typeref
    75,  # (49) expression ::= AMPERSAND expression
    75,  # (50) expression ::= ALIAS AMPERSAND expression
    75,  # (51) expression ::= NEXT expression
    75,  # (52) expression ::= PREV expression
    75,  # (53) expression ::= BYTESOF varortypeid
    75,  # (54) expression ::= SIZEOF varortypeid
    90,  # (55) leafexpression ::= oldid
    90,  # (56) leafexpression ::= OPENSQ expression CLOSESQ
    75,  # (57) expression ::= expression OPENSQ expression CLOSESQ
    75,  # (58) expression ::= expression DOT ID
    90,  # (59) leafexpression ::= STRING
    89,  # (60) cvalue ::= expression
    72,  # (61) statement ::= CONST newid ASSIGN cvalue SEMICOLON
    74,  # (62) typeref ::= INT OPENPAREN cvalue COMMA cvalue CLOSEPAREN
    74,  # (63) typeref ::= eitherid
    74,  # (64) typeref ::= OPENSQ typeref CLOSESQ
    74,  # (65) typeref ::= typeref OPENSQ cvalue CLOSESQ
    74,  # (66) typeref ::= typeref OPENSQ CLOSESQ
    74,  # (67) typeref ::= INDEXOF varortypeid
    72,  # (68) statement ::= TYPEDEF ID IS typeref SEMICOLON
    73,  # (69) newid ::= ID
    92,  # (70) oldid ::= ID
    93,  # (71) eitherid ::= ID
    91,  # (72) varortypeid ::= oldid
    91,  # (73) varortypeid ::= OPENPAREN typeref CLOSEPAREN
    75,  # (74) expression ::= startsubcall inputargs
    72,  # (75) statement ::= startsubcall inputargs SEMICOLON
    72,  # (76) statement ::= outputargs ASSIGN startsubcall inputargs SEMICOLON
    94,  # (77) startsubcall ::= leafexpression
    95,  # (78) inputargs ::= OPENPAREN inputarglist CLOSEPAREN
    95,  # (79) inputargs ::= OPENPAREN CLOSEPAREN
    97,  # (80) inputarglist ::= inputarg
    97,  # (81) inputarglist ::= inputarglist COMMA inputarg
    98,  # (82) inputarg ::= expression
    96,  # (83) outputargs ::= OPENPAREN outputarglist COMMA outputarg CLOSEPAREN
    99,  # (84) outputarglist ::= outputarg
    99,  # (85) outputarglist ::= outputarglist COMMA outputarg
   100,  # (86) outputarg ::= expression
    72,  # (87) statement ::= INTERFACE newsubid subparams submodifiers SEMICOLON
   107,  # (88) implementsstart ::= SUB newsubid IMPLEMENTS typeref
   103,  # (89) submodifiers ::= submodifiers EXTERN OPENPAREN STRING CLOSEPAREN
   101,  # (90) newsubid ::= newid
   106,  # (91) subimpldecl ::= IMPL SUB oldid
   104,  # (92) substart ::= IS
   105,  # (93) subend ::= END SUB
   102,  # (94) subparams ::= inparamlist
   102,  # (95) subparams ::= inparamlist COLON paramlist
   108,  # (96) inparamlist ::= paramlist
   109,  # (97) paramlist ::= OPENPAREN CLOSEPAREN
   109,  # (98) paramlist ::= OPENPAREN params CLOSEPAREN
   110,  # (99) params ::= param
   110,  # (100) params ::= param COMMA params
   111,  # (101) param ::= ID COLON typeref
    72,  # (102) statement ::= RECORD recordstart recordinherits IS recordmembers END RECORD
   112,  # (103) recordstart ::= eitherid
   113,  # (104) recordinherits ::= COLON typeref
   115,  # (105) recordmember ::= memberid recordat COLON typeref SEMICOLON
   117,  # (106) recordat ::=
   117,  # (107) recordat ::= AT OPENPAREN cvalue CLOSEPAREN
   116,  # (108) memberid ::= ID
    72,  # (109) statement ::= initdecl OPENBR initialisers CLOSEBR SEMICOLON
   118,  # (110) initdecl ::= VAR newid COLON typeref ASSIGN
   120,  # (111) initialiser ::= expression
   120,  # (112) initialiser ::= startbracedinitialiser initialisers CLOSEBR
   121,  # (113) startbracedinitialiser ::= OPENBR
    72,  # (114) statement ::= asmstart asms SEMICOLON
   122,  # (115) asmstart ::= ASM
   124,  # (116) asm ::= STRING
   124,  # (117) asm ::= NUMBER
   124,  # (118) asm ::= oldid
    70,  # (119) program ::= statements
    71,  # (120) statements ::=
    71,  # (121) statements ::= statements statement
    72,  # (122) statement ::= SEMICOLON
    82,  # (123) if_optional_else ::= if_else statements
    82,  # (124) if_optional_else ::= if_elseif if_conditional THEN statements if_optional_else
    86,  # (125) whens ::=
    86,  # (126) whens ::= whens when
    87,  # (127) when ::= beginwhen statements
    72,  # (128) statement ::= SUB newsubid subparams submodifiers substart statements subend SEMICOLON
    72,  # (129) statement ::= DECL SUB newsubid subparams submodifiers SEMICOLON
    72,  # (130) statement ::= subimpldecl substart statements subend SEMICOLON
    72,  # (131) statement ::= implementsstart substart statements subend SEMICOLON
   103,  # (132) submodifiers ::=
   113,  # (133) recordinherits ::=
   114,  # (134) recordmembers ::=
   114,  # (135) recordmembers ::= recordmember recordmembers
   119,  # (136) initialisers ::= initialiser
   119,  # (137) initialisers ::= initialisers COMMA initialiser
   120,  # (138) initialiser ::=
   123,  # (139) asms ::= asm
   123,  # (140) asms ::= asm COMMA asms
};

# For rule J, yyRuleInfoNRhs[J] contains the number of symbols on the
# right-hand side of that rule.
var yyRuleInfoNRhs: uint8[] := {
    2,  # (0) statement ::= RETURN SEMICOLON
    5,  # (1) statement ::= VAR newid COLON typeref SEMICOLON
    7,  # (2) statement ::= VAR newid COLON typeref ASSIGN expression SEMICOLON
    5,  # (3) statement ::= VAR newid ASSIGN expression SEMICOLON
    4,  # (4) statement ::= expression ASSIGN expression SEMICOLON
    4,  # (5) statement ::= startloopstatement statements END LOOP
    1,  # (6) startloopstatement ::= LOOP
    4,  # (7) statement ::= startwhilestatement statements END LOOP
    1,  # (8) initwhilestatement ::= WHILE
    3,  # (9) startwhilestatement ::= initwhilestatement conditional LOOP
    2,  # (10) statement ::= BREAK SEMICOLON
    2,  # (11) statement ::= CONTINUE SEMICOLON
    8,  # (12) statement ::= IF if_begin if_conditional THEN statements if_optional_else END IF
    0,  # (13) if_begin ::=
    1,  # (14) if_conditional ::= conditional
    0,  # (15) if_optional_else ::=
    1,  # (16) if_else ::= ELSE
    1,  # (17) if_elseif ::= ELSEIF
    5,  # (18) statement ::= startcase whens END CASE SEMICOLON
    3,  # (19) startcase ::= CASE expression IS
    3,  # (20) beginwhen ::= WHEN cvalue COLON
    3,  # (21) beginwhen ::= WHEN ELSE COLON
    3,  # (22) conditional ::= OPENPAREN conditional CLOSEPAREN
    2,  # (23) conditional ::= NOT conditional
    3,  # (24) conditional ::= conditional AND conditional
    3,  # (25) conditional ::= conditional OR conditional
    3,  # (26) conditional ::= expression EQOP expression
    3,  # (27) conditional ::= expression NEOP expression
    3,  # (28) conditional ::= expression LTOP expression
    3,  # (29) conditional ::= expression GEOP expression
    3,  # (30) conditional ::= expression GTOP expression
    3,  # (31) conditional ::= expression LEOP expression
    1,  # (32) leafexpression ::= NUMBER
    3,  # (33) leafexpression ::= OPENPAREN expression CLOSEPAREN
    1,  # (34) leafexpression ::= NIL
    1,  # (35) expression ::= leafexpression
    2,  # (36) expression ::= MINUS expression
    2,  # (37) expression ::= TILDE expression
    3,  # (38) expression ::= expression PLUS expression
    3,  # (39) expression ::= expression MINUS expression
    3,  # (40) expression ::= expression STAR expression
    3,  # (41) expression ::= expression SLASH expression
    3,  # (42) expression ::= expression PERCENT expression
    3,  # (43) expression ::= expression CARET expression
    3,  # (44) expression ::= expression AMPERSAND expression
    3,  # (45) expression ::= expression PIPE expression
    3,  # (46) expression ::= expression LSHIFT expression
    3,  # (47) expression ::= expression RSHIFT expression
    3,  # (48) expression ::= expression AS typeref
    2,  # (49) expression ::= AMPERSAND expression
    3,  # (50) expression ::= ALIAS AMPERSAND expression
    2,  # (51) expression ::= NEXT expression
    2,  # (52) expression ::= PREV expression
    2,  # (53) expression ::= BYTESOF varortypeid
    2,  # (54) expression ::= SIZEOF varortypeid
    1,  # (55) leafexpression ::= oldid
    3,  # (56) leafexpression ::= OPENSQ expression CLOSESQ
    4,  # (57) expression ::= expression OPENSQ expression CLOSESQ
    3,  # (58) expression ::= expression DOT ID
    1,  # (59) leafexpression ::= STRING
    1,  # (60) cvalue ::= expression
    5,  # (61) statement ::= CONST newid ASSIGN cvalue SEMICOLON
    6,  # (62) typeref ::= INT OPENPAREN cvalue COMMA cvalue CLOSEPAREN
    1,  # (63) typeref ::= eitherid
    3,  # (64) typeref ::= OPENSQ typeref CLOSESQ
    4,  # (65) typeref ::= typeref OPENSQ cvalue CLOSESQ
    3,  # (66) typeref ::= typeref OPENSQ CLOSESQ
    2,  # (67) typeref ::= INDEXOF varortypeid
    5,  # (68) statement ::= TYPEDEF ID IS typeref SEMICOLON
    1,  # (69) newid ::= ID
    1,  # (70) oldid ::= ID
    1,  # (71) eitherid ::= ID
    1,  # (72) varortypeid ::= oldid
    3,  # (73) varortypeid ::= OPENPAREN typeref CLOSEPAREN
    2,  # (74) expression ::= startsubcall inputargs
    3,  # (75) statement ::= startsubcall inputargs SEMICOLON
    5,  # (76) statement ::= outputargs ASSIGN startsubcall inputargs SEMICOLON
    1,  # (77) startsubcall ::= leafexpression
    3,  # (78) inputargs ::= OPENPAREN inputarglist CLOSEPAREN
    2,  # (79) inputargs ::= OPENPAREN CLOSEPAREN
    1,  # (80) inputarglist ::= inputarg
    3,  # (81) inputarglist ::= inputarglist COMMA inputarg
    1,  # (82) inputarg ::= expression
    5,  # (83) outputargs ::= OPENPAREN outputarglist COMMA outputarg CLOSEPAREN
    1,  # (84) outputarglist ::= outputarg
    3,  # (85) outputarglist ::= outputarglist COMMA outputarg
    1,  # (86) outputarg ::= expression
    5,  # (87) statement ::= INTERFACE newsubid subparams submodifiers SEMICOLON
    4,  # (88) implementsstart ::= SUB newsubid IMPLEMENTS typeref
    5,  # (89) submodifiers ::= submodifiers EXTERN OPENPAREN STRING CLOSEPAREN
    1,  # (90) newsubid ::= newid
    3,  # (91) subimpldecl ::= IMPL SUB oldid
    1,  # (92) substart ::= IS
    2,  # (93) subend ::= END SUB
    1,  # (94) subparams ::= inparamlist
    3,  # (95) subparams ::= inparamlist COLON paramlist
    1,  # (96) inparamlist ::= paramlist
    2,  # (97) paramlist ::= OPENPAREN CLOSEPAREN
    3,  # (98) paramlist ::= OPENPAREN params CLOSEPAREN
    1,  # (99) params ::= param
    3,  # (100) params ::= param COMMA params
    3,  # (101) param ::= ID COLON typeref
    7,  # (102) statement ::= RECORD recordstart recordinherits IS recordmembers END RECORD
    1,  # (103) recordstart ::= eitherid
    2,  # (104) recordinherits ::= COLON typeref
    5,  # (105) recordmember ::= memberid recordat COLON typeref SEMICOLON
    0,  # (106) recordat ::=
    4,  # (107) recordat ::= AT OPENPAREN cvalue CLOSEPAREN
    1,  # (108) memberid ::= ID
    5,  # (109) statement ::= initdecl OPENBR initialisers CLOSEBR SEMICOLON
    5,  # (110) initdecl ::= VAR newid COLON typeref ASSIGN
    1,  # (111) initialiser ::= expression
    3,  # (112) initialiser ::= startbracedinitialiser initialisers CLOSEBR
    1,  # (113) startbracedinitialiser ::= OPENBR
    3,  # (114) statement ::= asmstart asms SEMICOLON
    1,  # (115) asmstart ::= ASM
    1,  # (116) asm ::= STRING
    1,  # (117) asm ::= NUMBER
    1,  # (118) asm ::= oldid
    1,  # (119) program ::= statements
    0,  # (120) statements ::=
    2,  # (121) statements ::= statements statement
    1,  # (122) statement ::= SEMICOLON
    2,  # (123) if_optional_else ::= if_else statements
    5,  # (124) if_optional_else ::= if_elseif if_conditional THEN statements if_optional_else
    0,  # (125) whens ::=
    2,  # (126) whens ::= whens when
    2,  # (127) when ::= beginwhen statements
    8,  # (128) statement ::= SUB newsubid subparams submodifiers substart statements subend SEMICOLON
    6,  # (129) statement ::= DECL SUB newsubid subparams submodifiers SEMICOLON
    5,  # (130) statement ::= subimpldecl substart statements subend SEMICOLON
    5,  # (131) statement ::= implementsstart substart statements subend SEMICOLON
    0,  # (132) submodifiers ::=
    0,  # (133) recordinherits ::=
    0,  # (134) recordmembers ::=
    2,  # (135) recordmembers ::= recordmember recordmembers
    1,  # (136) initialisers ::= initialiser
    3,  # (137) initialisers ::= initialisers COMMA initialiser
    0,  # (138) initialiser ::=
    1,  # (139) asms ::= asm
    3,  # (140) asms ::= asm COMMA asms
};

sub yy_trace_shift(stateno: YYACTIONTYPE, msg: string) is
	print(msg);
	print(" '");
	print(yyTokenName[yytos.major]);
	print("', go to state ");
	print_i16(stateno as uint16);
	print_nl();
end sub;

sub CopyMinor(src: [YYMINORTYPE], dest: [YYMINORTYPE]) is
	MemCopy(src as [uint8], @bytesof YYMINORTYPE, dest as [uint8]);
end sub;

sub yy_reduce(yyruleno: YYACTIONTYPE, yylookahead: YYCODETYPE): (yyact: YYACTIONTYPE) is
	var yysize := yyRuleInfoNRhs[yyruleno as @indexof yyRuleInfoNRhs];
	#print("Reduce ");
	#print_i16(yyruleno);
	#if yysize != 0 then
	#	print(", go to state ");
	#	print_i16([yytos - (yysize as intptr)*@bytesof yyStackEntry].stateno);
	#end if;
	#print_nl();

	if yytos == &yystack[YYSTACKDEPTH] then
		yy_stack_overflow();
	end if;

	var yylhs: YYMINORTYPE;
	var yyrhs: YYMINORTYPE[YY_MAX_RHS_SYMBOLS];
	var pout := &yyrhs[0];
	var c := yysize;
	while c != 0 loop
		CopyMinor(&yytos.minor, pout);
		yytos := @prev yytos;
		pout := @next pout;
		c := c - 1;
	end loop;
interface Reducer();
sub reduce_0 implements Reducer is # 1 symbols on RHS
#line 66 "parser.y"

	Generate(MidReturn());

#line 1020 "parser.coh"
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_1 implements Reducer is # 4 symbols on RHS
#line 73 "parser.y"

	InitVariable(current_subr, yyrhs[3].yy237, yyrhs[1].yy25);

#line 1028 "parser.coh"
  yy_destructor(6,&yyrhs[2]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_2 implements Reducer is # 6 symbols on RHS
#line 78 "parser.y"

	InitVariable(current_subr, yyrhs[5].yy237, yyrhs[3].yy25);
    CheckExpressionType(yyrhs[1].yy161, yyrhs[5].yy237.vardata.type);

	var w := yyrhs[1].yy161.type.width as uint8;
    Generate(MidStore(w, yyrhs[1].yy161, MidDeref(w, MidAddress(yyrhs[5].yy237, 0))));

#line 1041 "parser.coh"
  yy_destructor(6,&yyrhs[4]);
  yy_destructor(2,&yyrhs[2]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_3 implements Reducer is # 4 symbols on RHS
#line 87 "parser.y"

	var type := yyrhs[1].yy161.type;
	if type == (0 as [Type]) then
		SimpleError("types cannot be inferred for untyped constants");
	end if;
	if IsScalar(type) == 0 then
		SimpleError("you can only assign scalars");
	end if;

	InitVariable(current_subr, yyrhs[3].yy237, type);
	CheckExpressionType(yyrhs[1].yy161, yyrhs[3].yy237.vardata.type);

	var w := yyrhs[1].yy161.type.width as uint8;
    Generate(MidStore(w, yyrhs[1].yy161, MidDeref(w, MidAddress(yyrhs[3].yy237, 0))));

#line 1063 "parser.coh"
  yy_destructor(2,&yyrhs[2]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_4 implements Reducer is # 3 symbols on RHS
#line 106 "parser.y"

	var type := yyrhs[3].yy161.type;
	var address := UndoLValue(yyrhs[3].yy161);

	CheckExpressionType(yyrhs[1].yy161, type);
	var w := type.width as uint8;
    Generate(MidStore(w, yyrhs[1].yy161, MidDeref(w, address)));

#line 1077 "parser.coh"
  yy_destructor(2,&yyrhs[2]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_5 implements Reducer is # 3 symbols on RHS
#line 139 "parser.y"

	TerminateNormalLoop(yyrhs[3].yy124);

#line 1086 "parser.coh"
  yy_destructor(10,&yyrhs[1]);
  yy_destructor(13,&yyrhs[0]);
end sub;
sub reduce_6 implements Reducer is # 0 symbols on RHS
#line 145 "parser.y"

	yylhs.yy124 := BeginNormalLoop();
	Generate(MidLabel(continue_label));

#line 1096 "parser.coh"
end sub;
sub reduce_7 implements Reducer is # 3 symbols on RHS
#line 153 "parser.y"

	TerminateNormalLoop(yyrhs[3].yy124);

#line 1103 "parser.coh"
  yy_destructor(10,&yyrhs[1]);
  yy_destructor(13,&yyrhs[0]);
end sub;
sub reduce_8 implements Reducer is # 0 symbols on RHS
#line 159 "parser.y"

	yylhs.yy124 := BeginNormalLoop();
	Generate(MidLabel(continue_label));

#line 1113 "parser.coh"
end sub;
sub reduce_9 implements Reducer is # 2 symbols on RHS
#line 166 "parser.y"

	yylhs.yy124 := yyrhs[2].yy124;
	var t := AllocLabel();
	break_label := AllocLabel();
	yyrhs[1].yy161.beq.truelabel := t;
	yyrhs[1].yy161.beq.falselabel := break_label;
	yyrhs[1].yy161.beq.fallthrough := t;
	GenerateConditional(yyrhs[1].yy161);
	yylhs.yy124.exit_label := break_label;

#line 1127 "parser.coh"
  yy_destructor(13,&yyrhs[0]);
end sub;
sub reduce_10 implements Reducer is # 1 symbols on RHS
#line 180 "parser.y"

	if break_label == 0 then
		SimpleError("nothing to break to");
	end if;
	Generate(MidJump(break_label));

#line 1138 "parser.coh"
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_11 implements Reducer is # 1 symbols on RHS
#line 188 "parser.y"

	if continue_label == 0 then
		SimpleError("nothing to continue to");
	end if;
	Generate(MidJump(continue_label));

#line 1149 "parser.coh"
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_12 implements Reducer is # 7 symbols on RHS
#line 198 "parser.y"

	Generate(MidLabel(current_if.exit_label));
	var oldif := current_if;
	current_if := current_if.next;
	Free(oldif as [uint8]);

#line 1160 "parser.coh"
  yy_destructor(26,&yyrhs[4]);
  yy_destructor(10,&yyrhs[1]);
  yy_destructor(12,&yyrhs[0]);
end sub;
sub reduce_13 implements Reducer is # -1 symbols on RHS
#line 206 "parser.y"

	var newif := InternalAlloc(@bytesof IfLabels) as [IfLabels];
	newif.next := current_if;
	current_if := newif;
	current_if.exit_label := AllocLabel();

#line 1173 "parser.coh"
end sub;
sub reduce_14 implements Reducer is # 0 symbols on RHS
#line 214 "parser.y"

	var t := AllocLabel();
	var f := AllocLabel();
	current_if.true_label := t;
	current_if.false_label := f;
	yyrhs[0].yy161.beq.truelabel := t;
	yyrhs[0].yy161.beq.falselabel := f;
	yyrhs[0].yy161.beq.fallthrough := t;
	GenerateConditional(yyrhs[0].yy161);

#line 1187 "parser.coh"
end sub;
sub reduce_15 implements Reducer is # -1 symbols on RHS
#line 226 "parser.y"

	Generate(MidLabel(current_if.false_label));

#line 1194 "parser.coh"
end sub;
sub reduce_16 implements Reducer is # 0 symbols on RHS
#line 234 "parser.y"

	Generate(MidJump(current_if.exit_label));
	Generate(MidLabel(current_if.false_label));

#line 1202 "parser.coh"
end sub;
sub reduce_17 implements Reducer is # 0 symbols on RHS
#line 240 "parser.y"

	Generate(MidJump(current_if.exit_label));
	Generate(MidLabel(current_if.false_label));

#line 1210 "parser.coh"
end sub;
sub reduce_18 implements Reducer is # 4 symbols on RHS
#line 248 "parser.y"

	if (current_case.seenelse == 0) and (current_case.next_label != 0) then
		Generate(MidLabel(current_case.next_label));
	end if;
	Generate(MidLabel(current_case.end_label));
	Generate(MidEndcase(current_case.width));

	var c := current_case;
	current_case := c.old_case;
	Free(c as [uint8]);

#line 1225 "parser.coh"
  yy_destructor(10,&yyrhs[2]);
  yy_destructor(65,&yyrhs[1]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_19 implements Reducer is # 2 symbols on RHS
#line 261 "parser.y"

	var c := InternalAlloc(@bytesof CaseLabels) as [CaseLabels];
	c.old_case := current_case;
	c.end_label := AllocLabel();
	current_case := c;

	if IsNum(yyrhs[1].yy161.type) == 0 then
		SimpleError("case only works on numbers");
	end if;

	c.width := NodeWidth(yyrhs[1].yy161);
	Generate(MidStartcase(c.width, yyrhs[1].yy161));

#line 1245 "parser.coh"
  yy_destructor(66,&yyrhs[0]);
end sub;
sub reduce_20 implements Reducer is # 2 symbols on RHS
#line 281 "parser.y"

	if current_case.seenelse != 0 then
		SimpleError("when else must go last");
	end if;

	if current_case.next_label != 0 then
		Generate(MidJump(current_case.end_label));
		Generate(MidLabel(current_case.next_label));
	end if;
	current_case.next_label := AllocLabel();

	Generate(MidWhencase(current_case.width, yyrhs[1].yy191, current_case.next_label));

#line 1263 "parser.coh"
  yy_destructor(6,&yyrhs[0]);
end sub;
sub reduce_21 implements Reducer is # 2 symbols on RHS
#line 296 "parser.y"

	if current_case.seenelse != 0 then
		SimpleError("only one when else allowed");
	end if;
	if current_case.next_label != 0 then
		Generate(MidJump(current_case.end_label));
		Generate(MidLabel(current_case.next_label));
	end if;
	current_case.next_label := 0;

	current_case.seenelse := 1;

#line 1280 "parser.coh"
  yy_destructor(9,&yyrhs[1]);
  yy_destructor(6,&yyrhs[0]);
end sub;
sub reduce_22 implements Reducer is # 2 symbols on RHS
#line 313 "parser.y"

	yylhs.yy161 := yyrhs[1].yy161;

#line 1289 "parser.coh"
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_23 implements Reducer is # 1 symbols on RHS
#line 325 "parser.y"

	yylhs.yy161 := yyrhs[0].yy161;
	Negate(yyrhs[0].yy161);

#line 1298 "parser.coh"
end sub;
sub reduce_24 implements Reducer is # 2 symbols on RHS
#line 331 "parser.y"

	yylhs.yy161 := MidBand(yyrhs[2].yy161, yyrhs[0].yy161, 0, 0, 0, 0);

#line 1305 "parser.coh"
  yy_destructor(47,&yyrhs[1]);
end sub;
sub reduce_25 implements Reducer is # 2 symbols on RHS
#line 336 "parser.y"

	yylhs.yy161 := MidBor(yyrhs[2].yy161, yyrhs[0].yy161, 0, 0, 0, 0);

#line 1313 "parser.coh"
  yy_destructor(48,&yyrhs[1]);
end sub;
sub reduce_26 implements Reducer is # 2 symbols on RHS
#line 366 "parser.y"

	yylhs.yy161 := ConditionalEq(yyrhs[2].yy161, yyrhs[0].yy161, 0);

#line 1321 "parser.coh"
  yy_destructor(55,&yyrhs[1]);
end sub;
sub reduce_27 implements Reducer is # 2 symbols on RHS
#line 371 "parser.y"

	yylhs.yy161 := ConditionalEq(yyrhs[2].yy161, yyrhs[0].yy161, 1);

#line 1329 "parser.coh"
  yy_destructor(56,&yyrhs[1]);
end sub;
sub reduce_28 implements Reducer is # 2 symbols on RHS
#line 376 "parser.y"

	yylhs.yy161 := ConditionalLt(yyrhs[2].yy161, yyrhs[0].yy161, 0);

#line 1337 "parser.coh"
  yy_destructor(51,&yyrhs[1]);
end sub;
sub reduce_29 implements Reducer is # 2 symbols on RHS
#line 381 "parser.y"

	yylhs.yy161 := ConditionalLt(yyrhs[2].yy161, yyrhs[0].yy161, 1);

#line 1345 "parser.coh"
  yy_destructor(54,&yyrhs[1]);
end sub;
sub reduce_30 implements Reducer is # 2 symbols on RHS
#line 386 "parser.y"

	yylhs.yy161 := ConditionalLt(yyrhs[0].yy161, yyrhs[2].yy161, 0);

#line 1353 "parser.coh"
  yy_destructor(53,&yyrhs[1]);
end sub;
sub reduce_31 implements Reducer is # 2 symbols on RHS
#line 391 "parser.y"

	yylhs.yy161 := ConditionalLt(yyrhs[0].yy161, yyrhs[2].yy161, 1);

#line 1361 "parser.coh"
  yy_destructor(52,&yyrhs[1]);
end sub;
sub reduce_32 implements Reducer is # 0 symbols on RHS
#line 398 "parser.y"
 yylhs.yy161 := MidConstant(yyrhs[0].yy0.number); 
#line 1367 "parser.coh"
end sub;
sub reduce_33 implements Reducer is # 2 symbols on RHS
#line 399 "parser.y"
 yylhs.yy161 := yyrhs[1].yy161; 
#line 1372 "parser.coh"
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_34 implements Reducer is # 0 symbols on RHS
#line 400 "parser.y"
 yylhs.yy161 := MidConstant(0); 
#line 1378 "parser.coh"
end sub;
sub reduce_35 implements Reducer is # 0 symbols on RHS
#line 403 "parser.y"
 yylhs.yy161 := yyrhs[0].yy161; 
#line 1383 "parser.coh"
end sub;
sub reduce_36 implements Reducer is # 1 symbols on RHS
#line 404 "parser.y"
 yylhs.yy161 := Expr1Simple(MIDCODE_NEG0, yyrhs[0].yy161); 
#line 1388 "parser.coh"
end sub;
sub reduce_37 implements Reducer is # 1 symbols on RHS
#line 405 "parser.y"
 yylhs.yy161 := Expr1Simple(MIDCODE_NOT0, yyrhs[0].yy161); 
#line 1393 "parser.coh"
end sub;
sub reduce_38 implements Reducer is # 2 symbols on RHS
#line 406 "parser.y"
 yylhs.yy161 := ExprAdd(yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1398 "parser.coh"
  yy_destructor(19,&yyrhs[1]);
end sub;
sub reduce_39 implements Reducer is # 2 symbols on RHS
#line 407 "parser.y"
 yylhs.yy161 := ExprSub(yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1404 "parser.coh"
  yy_destructor(14,&yyrhs[1]);
end sub;
sub reduce_40 implements Reducer is # 2 symbols on RHS
#line 408 "parser.y"
 yylhs.yy161 := Expr2Simple(MIDCODE_MUL0, MIDCODE_MUL0, yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1410 "parser.coh"
  yy_destructor(24,&yyrhs[1]);
end sub;
sub reduce_41 implements Reducer is # 2 symbols on RHS
#line 409 "parser.y"
 yylhs.yy161 := Expr2Simple(MIDCODE_DIVS0, MIDCODE_DIVU0, yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1416 "parser.coh"
  yy_destructor(23,&yyrhs[1]);
end sub;
sub reduce_42 implements Reducer is # 2 symbols on RHS
#line 410 "parser.y"
 yylhs.yy161 := Expr2Simple(MIDCODE_REMS0, MIDCODE_REMU0, yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1422 "parser.coh"
  yy_destructor(18,&yyrhs[1]);
end sub;
sub reduce_43 implements Reducer is # 2 symbols on RHS
#line 411 "parser.y"
 yylhs.yy161 := Expr2Simple(MIDCODE_EOR0, MIDCODE_EOR0, yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1428 "parser.coh"
  yy_destructor(50,&yyrhs[1]);
end sub;
sub reduce_44 implements Reducer is # 2 symbols on RHS
#line 412 "parser.y"
 yylhs.yy161 := Expr2Simple(MIDCODE_AND0, MIDCODE_AND0, yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1434 "parser.coh"
  yy_destructor(60,&yyrhs[1]);
end sub;
sub reduce_45 implements Reducer is # 2 symbols on RHS
#line 413 "parser.y"
 yylhs.yy161 := Expr2Simple(MIDCODE_OR0, MIDCODE_OR0, yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1440 "parser.coh"
  yy_destructor(49,&yyrhs[1]);
end sub;
sub reduce_46 implements Reducer is # 2 symbols on RHS
#line 414 "parser.y"
 yylhs.yy161 := ExprShift(MIDCODE_LSHIFT0, MIDCODE_LSHIFT0, yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1446 "parser.coh"
  yy_destructor(57,&yyrhs[1]);
end sub;
sub reduce_47 implements Reducer is # 2 symbols on RHS
#line 415 "parser.y"
 yylhs.yy161 := ExprShift(MIDCODE_RSHIFTS0, MIDCODE_RSHIFTU0, yyrhs[2].yy161, yyrhs[0].yy161); 
#line 1452 "parser.coh"
  yy_destructor(58,&yyrhs[1]);
end sub;
sub reduce_48 implements Reducer is # 2 symbols on RHS
#line 418 "parser.y"

	CheckNotPartialType(yyrhs[0].yy25);
	if (yyrhs[2].yy161.op != MIDCODE_CONSTANT) and (yyrhs[2].yy161.type.width != yyrhs[0].yy25.width) then
		if (IsPtr(yyrhs[2].yy161.type) != 0) or (IsPtr(yyrhs[0].yy25) != 0) then
			SimpleError("cast between pointer and non-pointer of different size");
		end if;

		yylhs.yy161 := MidCCast(yyrhs[0].yy25.width as uint8, yyrhs[2].yy161, IsSNum(yyrhs[2].yy161.type));
	else
		yylhs.yy161 := yyrhs[2].yy161;
	end if;
	yylhs.yy161.type := yyrhs[0].yy25;

#line 1470 "parser.coh"
  yy_destructor(59,&yyrhs[1]);
end sub;
sub reduce_49 implements Reducer is # 1 symbols on RHS
#line 433 "parser.y"

	yylhs.yy161 := UndoLValue(yyrhs[0].yy161);
	if yylhs.yy161.op == MIDCODE_ADDRESS then
		var sym := yylhs.yy161.address.sym;
		if IsScalar(sym.vardata.type) != 0 then
			SimpleError("you cannot take the address of scalar variables");
		end if;
	end if;

#line 1484 "parser.coh"
end sub;
sub reduce_50 implements Reducer is # 2 symbols on RHS
#line 444 "parser.y"

	yylhs.yy161 := UndoLValue(yyrhs[0].yy161);

#line 1491 "parser.coh"
  yy_destructor(60,&yyrhs[1]);
end sub;
sub reduce_51 implements Reducer is # 1 symbols on RHS
#line 456 "parser.y"

	if IsPtr(yyrhs[0].yy161.type) == 0 then
		parser_i_bad_next_prev();
	end if;
	yylhs.yy161 := MidC2Op(MIDCODE_ADD0,
		intptr_type.width as uint8,
		yyrhs[0].yy161,
		MidConstant(yyrhs[0].yy161.type.pointertype.element.stride as Arith)
	);
	yylhs.yy161.type := yyrhs[0].yy161.type;

#line 1507 "parser.coh"
end sub;
sub reduce_52 implements Reducer is # 1 symbols on RHS
#line 469 "parser.y"

	if IsPtr(yyrhs[0].yy161.type) == 0 then
		parser_i_bad_next_prev();
	end if;
	yylhs.yy161 := MidC2Op(MIDCODE_SUB0,
		intptr_type.width as uint8,
		yyrhs[0].yy161,
		MidConstant(yyrhs[0].yy161.type.pointertype.element.stride as Arith)
	);
	yylhs.yy161.type := yyrhs[0].yy161.type;

#line 1522 "parser.coh"
end sub;
sub reduce_53 implements Reducer is # 1 symbols on RHS
#line 482 "parser.y"

	yylhs.yy161 := MidConstant(yyrhs[0].yy25.width as Arith);

#line 1529 "parser.coh"
end sub;
sub reduce_54 implements Reducer is # 1 symbols on RHS
#line 487 "parser.y"

	if IsArray(yyrhs[0].yy25) == 0 then
		SimpleError("array expected");
	end if;
	yylhs.yy161 := MidConstant(yyrhs[0].yy25.arraytype.size as Arith);

#line 1539 "parser.coh"
end sub;
sub reduce_55 implements Reducer is # 0 symbols on RHS
#line 495 "parser.y"

	sub not_a_value() is
		StartError();
		print(yyrhs[0].yy237.name);
		print(" is not a value");
		EndError();
	end sub;

	case yyrhs[0].yy237.kind is
		when CONST:
			yylhs.yy161 := MidConstant(yyrhs[0].yy237.constant);

		when VAR:
			yylhs.yy161 := MidAddress(yyrhs[0].yy237, 0);
			yylhs.yy161.type := MakePointerType(yyrhs[0].yy237.vardata.type);
			yylhs.yy161 := MakeLValue(yylhs.yy161);

		when TYPE:
			# Subroutine instances are passed around as their type, even if it
			# does not *really* make sense. Every type must have a symbol, so
			# by using the type as a subroutine literal, we save on having to
			# create an extra symbol for it.
			if yyrhs[0].yy237.typedata.kind == TYPE_SUBROUTINE then
				yylhs.yy161 := MidSubref(yyrhs[0].yy237.typedata.subrtype.subr);
				yylhs.yy161.type := yyrhs[0].yy237.typedata.subrtype.subr.intfsubr.type;
			else
				not_a_value();
			end if;

		when else:
			not_a_value();
	end case;

#line 1576 "parser.coh"
end sub;
sub reduce_56 implements Reducer is # 2 symbols on RHS
#line 530 "parser.y"

	if IsPtr(yyrhs[1].yy161.type) == 0 then
		SimpleError("cannot dereference non-pointers");
	end if;

	yylhs.yy161 := MakeLValue(yyrhs[1].yy161);

#line 1587 "parser.coh"
  yy_destructor(5,&yyrhs[0]);
end sub;
sub reduce_57 implements Reducer is # 3 symbols on RHS
#line 539 "parser.y"

	var type := yyrhs[3].yy161.type;
	var address := MaybeUndoLValue(yyrhs[3].yy161);

	if IsArray(type) == 0 then
		StartError();
		print("you can only index an array, not a ");
		print(type.symbol.name);
		EndError();
	end if;

	CheckExpressionType(yyrhs[1].yy161, type.arraytype.indextype);
	if IsNum(yyrhs[1].yy161.type) == 0 then
		SimpleError("array indices must be numbers");
	end if;

	var elementtype := type.arraytype.element;
	var w := intptr_type.width as uint8;

	var displacement := MidC2Op(MIDCODE_MUL0, w,
				MidCCast(w, yyrhs[1].yy161, 0),
				MidConstant(elementtype.stride as int32));
	displacement.type := intptr_type;

	var adjustedaddress := MidC2Op(MIDCODE_ADD0, w, address, displacement);
	adjustedaddress.type := MakePointerType(elementtype);
	yylhs.yy161 := MakeLValue(adjustedaddress);

#line 1620 "parser.coh"
  yy_destructor(17,&yyrhs[2]);
  yy_destructor(5,&yyrhs[0]);
end sub;
sub reduce_58 implements Reducer is # 2 symbols on RHS
#line 569 "parser.y"

	var type := yyrhs[2].yy161.type;
	var address := yyrhs[2].yy161;

	sub BadType() is
		StartError();
		print(type.symbol.name);
		print(" is not a record or pointer to a record");
		EndError();
	end sub;

	if IsLValue(address) != 0 then
		address := MaybeUndoLValue(yyrhs[2].yy161);

		# Dereference pointers.

		while IsPtr(type) != 0 loop
			type := type.pointertype.element;
			CheckNotPartialType(type);
			address := MidDeref(intptr_type.width as uint8, address);
		end loop;
	elseif IsPtr(type) != 0 then
		type := type.pointertype.element;
	else
		BadType();
	end if;
	CheckNotPartialType(type);

	if IsRecord(type) == 0 then
		BadType();
	end if;

	var member := LookupSymbol(&type.recordtype.namespace, yyrhs[0].yy0.string);
	if member == (0 as [Symbol]) then
		StartError();
		print(type.symbol.name);
		print(" does not contain a member '");
		print(yyrhs[0].yy0.string);
		print("'");
		EndError();
	end if;
	Free(yyrhs[0].yy0.string as [uint8]);

	yylhs.yy161 := MidC2Op(MIDCODE_ADD0,
		intptr_type.width as uint8,
		address, MidConstant(member.vardata.offset as Arith));
	yylhs.yy161.type := MakePointerType(member.vardata.type);
	yylhs.yy161 := MakeLValue(yylhs.yy161);

#line 1675 "parser.coh"
  yy_destructor(8,&yyrhs[1]);
end sub;
sub reduce_59 implements Reducer is # 0 symbols on RHS
#line 620 "parser.y"

	# consumes yyrhs[0].yy0
	yylhs.yy161 := MidString(yyrhs[0].yy0.string);
	yylhs.yy161.type := MakePointerType(uint8_type);

#line 1685 "parser.coh"
end sub;
sub reduce_60 implements Reducer is # 0 symbols on RHS
#line 635 "parser.y"

	if yyrhs[0].yy161.op != MIDCODE_CONSTANT then
		parser_i_constant_error();
	end if;
	yylhs.yy191 := yyrhs[0].yy161.constant.value;
	Discard(yyrhs[0].yy161);

#line 1696 "parser.coh"
end sub;
sub reduce_61 implements Reducer is # 4 symbols on RHS
#line 644 "parser.y"

	yyrhs[3].yy237.kind := CONST;
	yyrhs[3].yy237.constant := yyrhs[1].yy191;

#line 1704 "parser.coh"
  yy_destructor(2,&yyrhs[2]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_62 implements Reducer is # 5 symbols on RHS
#line 653 "parser.y"

	if yyrhs[1].yy191 <= yyrhs[3].yy191 then
		SimpleError("invalid integer type range");
	end if;
	yylhs.yy25 := ArchGuessIntType(yyrhs[3].yy191, yyrhs[1].yy191);

#line 1716 "parser.coh"
  yy_destructor(16,&yyrhs[4]);
  yy_destructor(46,&yyrhs[2]);
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_63 implements Reducer is # 0 symbols on RHS
#line 661 "parser.y"

	var sym := yyrhs[0].yy237;
	if sym.kind == 0 then
		# Create a partial type.
		var type := AllocNewType();
		type.kind := TYPE_PARTIAL;

		sym.kind := TYPE;
		sym.typedata := type;
		type.symbol := sym;
	end if;
	if sym.kind != TYPE then
		StartError();
		print("expected ");
		print(sym.name);
		print(" to be a type");
		EndError();
	end if;
	yylhs.yy25 := sym.typedata;

#line 1743 "parser.coh"
end sub;
sub reduce_64 implements Reducer is # 2 symbols on RHS
#line 683 "parser.y"

	yylhs.yy25 := MakePointerType(yyrhs[1].yy25);

#line 1750 "parser.coh"
  yy_destructor(5,&yyrhs[0]);
end sub;
sub reduce_65 implements Reducer is # 3 symbols on RHS
#line 688 "parser.y"

	yylhs.yy25 := MakeArrayType(yyrhs[3].yy25, yyrhs[1].yy191 as uint16);

#line 1758 "parser.coh"
  yy_destructor(17,&yyrhs[2]);
  yy_destructor(5,&yyrhs[0]);
end sub;
sub reduce_66 implements Reducer is # 2 symbols on RHS
#line 693 "parser.y"

	yylhs.yy25 := MakeArrayType(yyrhs[2].yy25, 0);

#line 1767 "parser.coh"
  yy_destructor(17,&yyrhs[1]);
  yy_destructor(5,&yyrhs[0]);
end sub;
sub reduce_67 implements Reducer is # 1 symbols on RHS
#line 698 "parser.y"

	if IsArray(yyrhs[0].yy25) == 0 then
		StartError();
		print(yyrhs[0].yy25.symbol.name);
		print(" is not an array");
		EndError();
	end if;

	yylhs.yy25 := yyrhs[0].yy25.arraytype.indextype;

#line 1783 "parser.coh"
end sub;
sub reduce_68 implements Reducer is # 4 symbols on RHS
#line 710 "parser.y"

	# consumes yyrhs[3].yy0
	var sym := AddAlias(0 as [Namespace], yyrhs[3].yy0.string, yyrhs[1].yy25.symbol);

#line 1791 "parser.coh"
  yy_destructor(66,&yyrhs[2]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_69 implements Reducer is # 0 symbols on RHS
#line 719 "parser.y"

	# consumes X
	yylhs.yy237 := AddSymbol(0 as [Namespace], yyrhs[0].yy0.string);

#line 1801 "parser.coh"
end sub;
sub reduce_70 implements Reducer is # 0 symbols on RHS
#line 726 "parser.y"

	var name := yyrhs[0].yy0.string;
	var sym := LookupSymbol(0 as [Namespace], name);
	if sym == (0 as [Symbol]) then
		StartError();
		print("symbol '");
		print(name);
		print("' not found");
		EndError();
	end if;
	Free(name);
	yylhs.yy237 := sym;

#line 1818 "parser.coh"
end sub;
sub reduce_71 implements Reducer is # 0 symbols on RHS
#line 742 "parser.y"

	var name := yyrhs[0].yy0.string;
	var sym := LookupSymbol(0 as [Namespace], name);
	if sym == (0 as [Symbol]) then
		sym := AddSymbol(0 as [Namespace], name);
	else
		Free(name);
	end if;
	yylhs.yy237 := sym;

#line 1832 "parser.coh"
end sub;
sub reduce_72 implements Reducer is # 0 symbols on RHS
#line 755 "parser.y"

	case yyrhs[0].yy237.kind is
		when VAR:
			yylhs.yy25 := yyrhs[0].yy237.vardata.type;

		when TYPE:
			yylhs.yy25 := yyrhs[0].yy237.typedata;

		when else:
			SimpleError("simple type or variable name expected");
	end case;

#line 1848 "parser.coh"
end sub;
sub reduce_73 implements Reducer is # 2 symbols on RHS
#line 769 "parser.y"

	yylhs.yy25 := yyrhs[1].yy25;

#line 1855 "parser.coh"
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_74 implements Reducer is # 1 symbols on RHS
#line 800 "parser.y"

	var intfsubr := current_call.intfsubr;
	current_call.num_output_args := 1;
	i_check_sub_call_args();
	if intfsubr.num_output_parameters != 1 then
		SimpleError("subroutines called as functions must have exactly one output parameter");
	end if;

	var param := GetOutputParameter(intfsubr, 0);
	var w := param.vardata.type.width as uint8;
	var temp := AddSymbol(&current_subr.namespace, 0 as string);
	InitVariable(current_subr, temp, param.vardata.type);

	Generate(MidCall(yyrhs[0].yy161, current_call.expr, intfsubr));
    Generate(MidStore(w, MidPoparg(w, intfsubr, param, 0), MidDeref(w, MidAddress(temp, 0))));

	i_end_call();

	yylhs.yy161 := MidDeref(w, MidAddress(temp, 0));
	yylhs.yy161.type := param.vardata.type;

#line 1881 "parser.coh"
end sub;
sub reduce_75 implements Reducer is # 2 symbols on RHS
#line 823 "parser.y"

	var intfsubr := current_call.intfsubr;
	i_check_sub_call_args();
	if intfsubr.num_output_parameters != 0 then
		SimpleError("subroutine requires output arguments");
	end if;

	Generate(MidCall(yyrhs[1].yy161, current_call.expr, intfsubr));

	i_end_call();

#line 1896 "parser.coh"
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_76 implements Reducer is # 4 symbols on RHS
#line 836 "parser.y"

	var intfsubr := current_call.intfsubr;
	i_check_sub_call_args();

	Generate(MidCall(yyrhs[1].yy161, current_call.expr, intfsubr));

	var paramindex := intfsubr.num_output_parameters;
	var count: uint8 := 0;
	var node := yyrhs[4].yy161;
	while node != (0 as [Node]) loop
		if paramindex == 0 then
			SimpleError("too many output arguments");
		end if;

		paramindex := paramindex - 1;
		var param := GetOutputParameter(intfsubr, paramindex);

		var arg := node.left;
		node.left := (0 as [Node]);
		node := node.right;

		if IsPtr(arg.type) == 0 then
			SimpleError("you can only assign to lvalues");
		end if;

		CheckExpressionType(arg, MakePointerType(param.vardata.type));
		CheckNotPartialType(param.vardata.type);
		CheckNotPartialType(arg.type);

		var w := param.vardata.type.width as uint8;
		Generate(
			MidStore(
				w,
				MidPoparg(w, intfsubr, param, count),
				MidDeref(w, arg)
			)
		);

		count := count + 1;
		param := param.vardata.next_parameter;
	end loop;
	Discard(yyrhs[4].yy161);

	if count != intfsubr.num_output_parameters then
		SimpleError("too few output arguments");
	end if;

	i_end_call();

#line 1950 "parser.coh"
  yy_destructor(2,&yyrhs[3]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_77 implements Reducer is # 0 symbols on RHS
#line 887 "parser.y"

	if IsSubroutine(yyrhs[0].yy161.type) == 0 then
		StartError();
		print("expected ");
		print(yyrhs[0].yy161.type.symbol.name);
		print(" to be a subroutine");
		EndError();
	end if;

	var call := InternalAlloc(@bytesof SubroutineCall) as [SubroutineCall];
	call.parent := current_call;
	var subr := yyrhs[0].yy161.type.subrtype.subr;
	call.expr := yyrhs[0].yy161;
	call.intfsubr := subr;
	call.input_parameter := GetInputParameter(subr, 0);
	call.output_parameter := GetOutputParameter(subr, 0);
	current_call := call;

#line 1974 "parser.coh"
end sub;
sub reduce_78 implements Reducer is # 2 symbols on RHS
#line 913 "parser.y"
 yylhs.yy161 := yyrhs[1].yy161; 
#line 1979 "parser.coh"
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_79 implements Reducer is # 1 symbols on RHS
#line 916 "parser.y"
 yylhs.yy161 := MidEnd(); 
#line 1985 "parser.coh"
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_80 implements Reducer is # 0 symbols on RHS
#line 920 "parser.y"
 yylhs.yy161 := yyrhs[0].yy161; 
#line 1991 "parser.coh"
end sub;
sub reduce_81 implements Reducer is # 2 symbols on RHS
#line 923 "parser.y"

	Discard(yyrhs[0].yy161.left);
	yyrhs[0].yy161.left := yyrhs[2].yy161;
	yylhs.yy161 := yyrhs[0].yy161;

#line 2000 "parser.coh"
  yy_destructor(46,&yyrhs[1]);
end sub;
sub reduce_82 implements Reducer is # 0 symbols on RHS
#line 931 "parser.y"

	var param := current_call.input_parameter;
	if param == (0 as [Symbol]) then
		StartError();
		print("too many parameters in call to ");
		print(current_call.intfsubr.symbol.name);
		EndError();
	end if;

	current_call.input_parameter := current_call.input_parameter.vardata.next_parameter;
	CheckExpressionType(yyrhs[0].yy161, param.vardata.type);
	CheckNotPartialType(param.vardata.type);
	CheckNotPartialType(yyrhs[0].yy161.type);
	current_call.num_input_args := current_call.num_input_args + 1;
	yylhs.yy161 := MidArg(NodeWidth(yyrhs[0].yy161), MidEnd(), yyrhs[0].yy161,
		current_call.intfsubr,
		param,
		current_call.intfsubr.num_input_parameters - current_call.num_input_args);

#line 2024 "parser.coh"
end sub;
sub reduce_83 implements Reducer is # 4 symbols on RHS
#line 962 "parser.y"

	yylhs.yy161 := MidPair(yyrhs[1].yy161, yyrhs[3].yy161);

#line 2031 "parser.coh"
  yy_destructor(46,&yyrhs[2]);
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_84 implements Reducer is # 0 symbols on RHS
#line 968 "parser.y"

	yylhs.yy161 := MidPair(yyrhs[0].yy161, 0 as [Node]);

#line 2040 "parser.coh"
end sub;
sub reduce_85 implements Reducer is # 2 symbols on RHS
#line 973 "parser.y"

	yylhs.yy161 := MidPair(yyrhs[0].yy161, yyrhs[2].yy161);

#line 2047 "parser.coh"
  yy_destructor(46,&yyrhs[1]);
end sub;
sub reduce_86 implements Reducer is # 0 symbols on RHS
#line 979 "parser.y"

	yylhs.yy161 := UndoLValue(yyrhs[0].yy161);

#line 2055 "parser.coh"
end sub;
sub reduce_87 implements Reducer is # 4 symbols on RHS
#line 1001 "parser.y"

	preparing_subr.flags := preparing_subr.flags | SUB_IS_INTERFACE;
	EmitterEmitSubroutineFlags(preparing_subr);

	current_subr := preparing_subr;
	Generate(MidStartsub(current_subr));
	Generate(MidEndsub(current_subr));
	ReportWorkspaces(current_subr);

	current_subr := current_subr.parent;

#line 2070 "parser.coh"
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_88 implements Reducer is # 3 symbols on RHS
#line 1017 "parser.y"

	sub not_an_interface() is
		SimpleError("type is not an interface");
	end sub;

	if IsSubroutine(yyrhs[0].yy25) == 0 then
		not_an_interface();
	end if;
	var intfsubr := yyrhs[0].yy25.subrtype.subr;
	if (intfsubr.flags & SUB_IS_INTERFACE) == 0 then
		not_an_interface();
	end if;

	preparing_subr.flags := preparing_subr.flags | SUB_IS_IMPLEMENTATION;
	preparing_subr.intfsubr := intfsubr;
	preparing_subr.type := yyrhs[0].yy25;
	EmitterReferenceSubroutine(current_subr, intfsubr);
	EmitterReferenceSubroutine(intfsubr, preparing_subr);

	preparing_subr.num_input_parameters := intfsubr.num_input_parameters;
	if preparing_subr.num_input_parameters != 0 then
		CopyParameterList(intfsubr.namespace.first, preparing_subr);
	end if;

	preparing_subr.num_output_parameters := intfsubr.num_output_parameters;
	if preparing_subr.num_output_parameters != 0 then
		CopyParameterList(GetOutputParameter(intfsubr, 0), preparing_subr);
	end if;

	EmitterEmitInputParameters(preparing_subr);
	EmitterEmitOutputParameters(preparing_subr);
	EmitterEmitSubroutineFlags(preparing_subr);

#line 2108 "parser.coh"
  yy_destructor(69,&yyrhs[1]);
end sub;
sub reduce_89 implements Reducer is # 4 symbols on RHS
#line 1054 "parser.y"

	EmitterDeclareExternalSubroutine(preparing_subr.id, yyrhs[1].yy0.string);

#line 2116 "parser.coh"
  yy_destructor(11,&yyrhs[3]);
  yy_destructor(16,&yyrhs[2]);
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_90 implements Reducer is # 0 symbols on RHS
#line 1060 "parser.y"

	preparing_subr := InternalAlloc(@bytesof Subroutine) as [Subroutine];
	preparing_subr.namespace.parent := &current_subr.namespace;
	preparing_subr.parent := current_subr;
	preparing_subr.id := AllocSubrId();

	var type := AllocNewType();
	type.kind := TYPE_SUBROUTINE;
	type.width := intptr_type.width;
	type.alignment := intptr_type.alignment;
	type.stride := intptr_type.stride;
	type.subrtype.subr := preparing_subr;
	preparing_subr.type := type;
	preparing_subr.intfsubr := preparing_subr;

	yyrhs[0].yy237.kind := TYPE;
	yyrhs[0].yy237.typedata := type;
	type.symbol := yyrhs[0].yy237;
	preparing_subr.symbol := yyrhs[0].yy237;

	EmitterDeclareSubroutine(preparing_subr);
	yylhs.yy237 := yyrhs[0].yy237;

#line 2146 "parser.coh"
end sub;
sub reduce_91 implements Reducer is # 2 symbols on RHS
#line 1085 "parser.y"

	if (yyrhs[0].yy237.kind != TYPE) or (IsSubroutine(yyrhs[0].yy237.typedata) == 0) then
		SimpleError("not a subroutine");
	end if;
	preparing_subr := yyrhs[0].yy237.typedata.subrtype.subr;

	if (preparing_subr.flags & SUB_HAS_IMPL) != 0 then
		SimpleError("subroutine already implemented");
	end if;
	if preparing_subr.parent != current_subr then
		SimpleError("cannot implement subroutine here");
	end if;

#line 2163 "parser.coh"
  yy_destructor(25,&yyrhs[1]);
end sub;
sub reduce_92 implements Reducer is # 0 symbols on RHS
#line 1100 "parser.y"

	var sl := InternalAlloc(@bytesof SubroutineLabels) as [SubroutineLabels];
	sl.old_labels := current_subr_def;
	sl.old_break_label := break_label;
	break_label := 0;
	sl.old_continue_label := continue_label;
	continue_label := 0;
	current_subr_def := sl;

	current_subr := preparing_subr;
	Generate(MidStartsub(current_subr));
	current_subr.flags := current_subr.flags | SUB_HAS_IMPL;

#line 2181 "parser.coh"
end sub;
sub reduce_93 implements Reducer is # 1 symbols on RHS
#line 1115 "parser.y"

	Generate(MidEndsub(current_subr));

	ReportWorkspaces(current_subr);
	break_label := current_subr_def.old_break_label;
	continue_label := current_subr_def.old_continue_label;
	var ll := current_subr_def;
	current_subr_def := ll.old_labels;
	Free(ll as [uint8]);

	var subr := current_subr;
	current_subr := subr.parent;

	DestructSubroutineContents(subr);

#line 2200 "parser.coh"
  yy_destructor(25,&yyrhs[0]);
end sub;
sub reduce_94 implements Reducer is # 0 symbols on RHS
#line 1132 "parser.y"

	preparing_subr.num_output_parameters := 0;

	EmitterEmitInputParameters(preparing_subr);
	EmitterEmitOutputParameters(preparing_subr);

#line 2211 "parser.coh"
end sub;
sub reduce_95 implements Reducer is # 2 symbols on RHS
#line 1140 "parser.y"

	preparing_subr.num_output_parameters := CountParameters(yyrhs[0].yy237);

	EmitterEmitInputParameters(preparing_subr);
	EmitterEmitOutputParameters(preparing_subr);

#line 2221 "parser.coh"
  yy_destructor(6,&yyrhs[1]);
end sub;
sub reduce_96 implements Reducer is # 0 symbols on RHS
#line 1148 "parser.y"

	preparing_subr.num_input_parameters := CountParameters(yyrhs[0].yy237);

#line 2229 "parser.coh"
end sub;
sub reduce_97 implements Reducer is # 1 symbols on RHS
#line 1154 "parser.y"

	yylhs.yy237 := 0 as [Symbol];

#line 2236 "parser.coh"
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_98 implements Reducer is # 2 symbols on RHS
#line 1159 "parser.y"

	yylhs.yy237 := yyrhs[1].yy237;

#line 2244 "parser.coh"
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_99 implements Reducer is # 0 symbols on RHS
#line 1165 "parser.y"

	yylhs.yy237 := yyrhs[0].yy237;

#line 2252 "parser.coh"
end sub;
sub reduce_100 implements Reducer is # 2 symbols on RHS
#line 1170 "parser.y"

	yyrhs[2].yy237.vardata.next_parameter := yyrhs[0].yy237;
	yylhs.yy237 := yyrhs[2].yy237;

#line 2260 "parser.coh"
  yy_destructor(46,&yyrhs[1]);
end sub;
sub reduce_101 implements Reducer is # 2 symbols on RHS
#line 1177 "parser.y"

	# consumes yyrhs[2].yy0
	yylhs.yy237 := AddSymbol(&preparing_subr.namespace, yyrhs[2].yy0.string);

	InitVariable(preparing_subr, yylhs.yy237, yyrhs[0].yy25);

#line 2271 "parser.coh"
  yy_destructor(6,&yyrhs[1]);
end sub;
sub reduce_102 implements Reducer is # 6 symbols on RHS
#line 1197 "parser.y"

	current_type.stride := ArchAlignUp(current_type.width, current_type.alignment);

#line 2279 "parser.coh"
  yy_destructor(66,&yyrhs[3]);
  yy_destructor(10,&yyrhs[1]);
  yy_destructor(20,&yyrhs[0]);
end sub;
sub reduce_103 implements Reducer is # 0 symbols on RHS
#line 1202 "parser.y"

	case yyrhs[0].yy237.kind is
		when TYPE:
			current_type := yyrhs[0].yy237.typedata;
			if current_type.kind != TYPE_PARTIAL then
				SymbolRedeclarationError();
			end if;

		when 0:
			current_type := AllocNewType();
			yyrhs[0].yy237.kind := TYPE;
			yyrhs[0].yy237.typedata := current_type;
			current_type.symbol := yyrhs[0].yy237;

		when else:
			SymbolRedeclarationError();
	end case;

	current_type.kind := TYPE_RECORD;

#line 2306 "parser.coh"
end sub;
sub reduce_104 implements Reducer is # 1 symbols on RHS
#line 1226 "parser.y"

	CheckNotPartialType(yyrhs[0].yy25);
	if IsRecord(yyrhs[0].yy25) == 0 then
		StartError();
		print(yyrhs[0].yy25.symbol.name);
		print(" is not a record type");
		EndError();
	end if;

	current_type.alignment := yyrhs[0].yy25.alignment;
	current_type.width := yyrhs[0].yy25.width;
	current_type.recordtype.namespace.parent := &yyrhs[0].yy25.recordtype.namespace;

#line 2323 "parser.coh"
end sub;
sub reduce_105 implements Reducer is # 4 symbols on RHS
#line 1244 "parser.y"

	CheckNotPartialType(yyrhs[1].yy25);
	if yyrhs[1].yy25.alignment > current_type.alignment then
		current_type.alignment := yyrhs[1].yy25.alignment;
	end if;
	yyrhs[4].yy237.kind := VAR;
	yyrhs[4].yy237.vardata := InternalAlloc(@bytesof VarSymbol) as [VarSymbol];
	yyrhs[4].yy237.vardata.type := yyrhs[1].yy25;
	ArchInitMember(current_type, yyrhs[4].yy237, yyrhs[3].yy54);

#line 2337 "parser.coh"
  yy_destructor(6,&yyrhs[2]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_106 implements Reducer is # -1 symbols on RHS
#line 1257 "parser.y"

	yylhs.yy54 := current_type.width;

#line 2346 "parser.coh"
end sub;
sub reduce_107 implements Reducer is # 3 symbols on RHS
#line 1262 "parser.y"

	yylhs.yy54 := yyrhs[1].yy191 as Size;

#line 2353 "parser.coh"
  yy_destructor(16,&yyrhs[2]);
  yy_destructor(4,&yyrhs[0]);
end sub;
sub reduce_108 implements Reducer is # 0 symbols on RHS
#line 1268 "parser.y"

	# consumes yyrhs[0].yy0
	yylhs.yy237 := AddSymbol(&current_type.recordtype.namespace, yyrhs[0].yy0.string);
	current_type.recordtype.members := current_type.recordtype.members + 1;

#line 2364 "parser.coh"
end sub;
sub reduce_109 implements Reducer is # 4 symbols on RHS
#line 1364 "parser.y"

	CheckEndOfInitialiser();
	Generate(MidEndinit());

#line 2372 "parser.coh"
  yy_destructor(31,&yyrhs[3]);
  yy_destructor(32,&yyrhs[1]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_110 implements Reducer is # 4 symbols on RHS
#line 1370 "parser.y"

	# We don't call InitVariable() because we don't want this variable
	# allocated to a workspace.

	CheckNotPartialType(yyrhs[1].yy25);
	yyrhs[3].yy237.kind := VAR;
	yyrhs[3].yy237.vardata := InternalAlloc(@bytesof VarSymbol) as [VarSymbol];
	yyrhs[3].yy237.vardata.type := yyrhs[1].yy25;
	yyrhs[3].yy237.vardata.subr := current_subr;
	yyrhs[3].yy237.vardata.wsid := WSID_STATIC;
	yyrhs[3].yy237.vardata.offset := AllocLabel();

	if (IsArray(yyrhs[1].yy25) == 0) and (IsRecord(yyrhs[1].yy25) == 0) then
		SimpleError("static initialisers only work on arrays or records");
	end if;
	if (IsRecord(yyrhs[1].yy25) != 0) and (yyrhs[1].yy25.recordtype.namespace.parent != (0 as [Namespace])) then
		SimpleError("you can't statically initialise an inherited record");
	end if;

	if IsRecord(yyrhs[1].yy25) != 0 then
		current_member := yyrhs[1].yy25.recordtype.namespace.first;
	end if;

	current_type := yyrhs[1].yy25;
	current_offset := 0;
	current_global_offset := 0;

	Generate(MidStartinit(yyrhs[3].yy237));

#line 2408 "parser.coh"
  yy_destructor(6,&yyrhs[2]);
  yy_destructor(2,&yyrhs[0]);
end sub;
sub reduce_111 implements Reducer is # 0 symbols on RHS
#line 1406 "parser.y"

	var member: [Symbol];
	var type: [Type];
	(member, type) := GetInitedMemberChecked();

	AlignTo(type.alignment);
	var w := type.width;
	case yyrhs[0].yy161.op is
		when MIDCODE_CONSTANT:
			if IsNum(type) == 0 then
				SimpleError("initialiser must be an number");
			end if;
			Generate(MidInit(w as uint8, yyrhs[0].yy161.constant.value));

		when MIDCODE_STRING:
			if (IsPtr(type) == 0) or (type.pointertype.element != uint8_type) then
				SimpleError("initialiser must be a string");
			end if;
			Generate(MidInitstring(yyrhs[0].yy161.string.text));

		when MIDCODE_ADDRESS:
			if type != yyrhs[0].yy161.type then
				SimpleError("initialiser of wrong type");
			end if;
			Generate(MidInitaddress(yyrhs[0].yy161.address.sym, yyrhs[0].yy161.address.off));

		when MIDCODE_SUBREF:
			if type != yyrhs[0].yy161.type then
				SimpleError("initialiser of wrong type");
			end if;
			Generate(MidInitsubref(yyrhs[0].yy161.subref.subr));

		when else:
			parser_i_constant_error();
	end case;
	Discard(yyrhs[0].yy161);

	current_offset := current_offset + w;
	current_global_offset := current_global_offset + w;

#line 2454 "parser.coh"
end sub;
sub reduce_112 implements Reducer is # 2 symbols on RHS
#line 1448 "parser.y"

	CheckEndOfInitialiser();

	current_offset := current_offset + yyrhs[2].yy140.old_current_offset;
	current_type := yyrhs[2].yy140.old_current_type;
	current_member := yyrhs[2].yy140.old_current_member;
	Free(yyrhs[2].yy140 as [uint8]);

#line 2466 "parser.coh"
  yy_destructor(32,&yyrhs[0]);
end sub;
sub reduce_113 implements Reducer is # 0 symbols on RHS
#line 1459 "parser.y"

	var member: [Symbol];
	var type: [Type];
	(member, type) := GetInitedMemberChecked();
	AlignTo(type.alignment);

	yylhs.yy140 := InternalAlloc(@bytesof NestedTypeInit) as [NestedTypeInit];
	yylhs.yy140.old_current_type := current_type;
	yylhs.yy140.old_current_member := current_member;
	yylhs.yy140.old_current_offset := current_offset;

	current_type := type;
	current_offset := 0;
	if IsRecord(type) != 0 then
		current_member := type.recordtype.namespace.first;
	elseif IsArray(type) != 0 then
		current_member := 0 as [Symbol];
	else
		SimpleError("braced initialised can only initialise arrays or records");
	end if;

#line 2492 "parser.coh"
end sub;
sub reduce_114 implements Reducer is # 2 symbols on RHS
#line 1484 "parser.y"

	Generate(MidAsmend());

#line 2499 "parser.coh"
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_115 implements Reducer is # 0 symbols on RHS
#line 1489 "parser.y"

	Generate(MidAsmstart());

#line 2507 "parser.coh"
end sub;
sub reduce_116 implements Reducer is # 0 symbols on RHS
#line 1497 "parser.y"

	Generate(MidAsmtext(yyrhs[0].yy0.string));
	Free(yyrhs[0].yy0.string);

#line 2515 "parser.coh"
end sub;
sub reduce_117 implements Reducer is # 0 symbols on RHS
#line 1503 "parser.y"

	Generate(MidAsmvalue(yyrhs[0].yy0.number));

#line 2522 "parser.coh"
end sub;
sub reduce_118 implements Reducer is # 0 symbols on RHS
#line 1508 "parser.y"

	sub bad_reference() is
		SimpleError("you can only emit references to variables, subroutines, or constants");
	end sub;

	case yyrhs[0].yy237.kind is
		when TYPE:
			if IsSubroutine(yyrhs[0].yy237.typedata) != 0 then
				EmitterReferenceSubroutine(current_subr, yyrhs[0].yy237.typedata.subrtype.subr);
				Generate(MidAsmsubref(yyrhs[0].yy237.typedata.subrtype.subr));
			else
				bad_reference();
			end if;

		when VAR:
			Generate(MidAsmsymbol(yyrhs[0].yy237));

		when CONST:
			Generate(MidAsmvalue(yyrhs[0].yy237.constant));

		when else:
			bad_reference();
	end case;

#line 2550 "parser.coh"
end sub;
sub reduce_124 implements Reducer is # 4 symbols on RHS
#line 231 "parser.y"


#line 2556 "parser.coh"
  yy_destructor(26,&yyrhs[2]);
end sub;
sub reduce_128 implements Reducer is # 7 symbols on RHS
#line 991 "parser.y"


#line 2563 "parser.coh"
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_129 implements Reducer is # 5 symbols on RHS
#line 994 "parser.y"


#line 2570 "parser.coh"
  yy_destructor(25,&yyrhs[4]);
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_130 implements Reducer is # 4 symbols on RHS
#line 997 "parser.y"


#line 2578 "parser.coh"
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_131 implements Reducer is # 4 symbols on RHS
#line 1014 "parser.y"


#line 2585 "parser.coh"
  yy_destructor(22,&yyrhs[0]);
end sub;
sub reduce_137 implements Reducer is # 2 symbols on RHS
#line 1401 "parser.y"


#line 2592 "parser.coh"
  yy_destructor(46,&yyrhs[1]);
end sub;
sub reduce_140 implements Reducer is # 2 symbols on RHS
#line 1494 "parser.y"


#line 2599 "parser.coh"
  yy_destructor(46,&yyrhs[1]);
end sub;
sub reduce_default implements Reducer is
  # (119) program ::= statements
  # (120) statements ::=
  # (121) statements ::= statements statement
  # (122) statement ::= SEMICOLON
  # (123) if_optional_else ::= if_else statements
  # (125) whens ::=
  # (126) whens ::= whens when
  # (127) when ::= beginwhen statements
  # (132) submodifiers ::=
  # (133) recordinherits ::=
  # (134) recordmembers ::=
  # (135) recordmembers ::= recordmember recordmembers
  # (136) initialisers ::= initialiser
  # (138) initialiser ::=
  # (139) asms ::= asm
end sub;
var reducers: Reducer[] := {
	reduce_0,
	reduce_1,
	reduce_2,
	reduce_3,
	reduce_4,
	reduce_5,
	reduce_6,
	reduce_7,
	reduce_8,
	reduce_9,
	reduce_10,
	reduce_11,
	reduce_12,
	reduce_13,
	reduce_14,
	reduce_15,
	reduce_16,
	reduce_17,
	reduce_18,
	reduce_19,
	reduce_20,
	reduce_21,
	reduce_22,
	reduce_23,
	reduce_24,
	reduce_25,
	reduce_26,
	reduce_27,
	reduce_28,
	reduce_29,
	reduce_30,
	reduce_31,
	reduce_32,
	reduce_33,
	reduce_34,
	reduce_35,
	reduce_36,
	reduce_37,
	reduce_38,
	reduce_39,
	reduce_40,
	reduce_41,
	reduce_42,
	reduce_43,
	reduce_44,
	reduce_45,
	reduce_46,
	reduce_47,
	reduce_48,
	reduce_49,
	reduce_50,
	reduce_51,
	reduce_52,
	reduce_53,
	reduce_54,
	reduce_55,
	reduce_56,
	reduce_57,
	reduce_58,
	reduce_59,
	reduce_60,
	reduce_61,
	reduce_62,
	reduce_63,
	reduce_64,
	reduce_65,
	reduce_66,
	reduce_67,
	reduce_68,
	reduce_69,
	reduce_70,
	reduce_71,
	reduce_72,
	reduce_73,
	reduce_74,
	reduce_75,
	reduce_76,
	reduce_77,
	reduce_78,
	reduce_79,
	reduce_80,
	reduce_81,
	reduce_82,
	reduce_83,
	reduce_84,
	reduce_85,
	reduce_86,
	reduce_87,
	reduce_88,
	reduce_89,
	reduce_90,
	reduce_91,
	reduce_92,
	reduce_93,
	reduce_94,
	reduce_95,
	reduce_96,
	reduce_97,
	reduce_98,
	reduce_99,
	reduce_100,
	reduce_101,
	reduce_102,
	reduce_103,
	reduce_104,
	reduce_105,
	reduce_106,
	reduce_107,
	reduce_108,
	reduce_109,
	reduce_110,
	reduce_111,
	reduce_112,
	reduce_113,
	reduce_114,
	reduce_115,
	reduce_116,
	reduce_117,
	reduce_118,
	reduce_default,
	reduce_default,
	reduce_default,
	reduce_default,
	reduce_default,
	reduce_124,
	reduce_default,
	reduce_default,
	reduce_default,
	reduce_128,
	reduce_129,
	reduce_130,
	reduce_131,
	reduce_default,
	reduce_default,
	reduce_default,
	reduce_default,
	reduce_default,
	reduce_137,
	reduce_default,
	reduce_default,
	reduce_140,
};
(reducers[yyruleno as uint8])();
	CopyMinor(&yylhs, &([@next yytos].minor));

	var yygoto := yyRuleInfoLhs[yyruleno as @indexof yyRuleInfoLhs];
	var stateno := yytos.stateno;
	yyact := yy_default[stateno as @indexof yy_default];
	if stateno <= YY_REDUCE_COUNT then
		var i := (yy_reduce_ofst[stateno as @indexof yy_reduce_ofst] as @indexof yy_action)
				+ (yygoto as @indexof yy_action);
		if (i>=0) and (i<YY_ACTTAB_COUNT) and (yy_lookahead[i as @indexof yy_lookahead] == yygoto) then
			yyact := yy_action[i];
		end if;
	end if;

	yytos := @next yytos;
	yytos.stateno := yyact;
	yytos.major := yygoto;

	#yy_trace_shift(yyact, "...then shift");
end sub;

# parse failure code
sub yy_parse_failed() is
	yy_pop_all_parser_stack();
end sub;

# syntax error code
sub yy_syntax_error(yymajor: YYCODETYPE, yyminor: [ParseTOKENTYPE]) is
#line 31 "parser.y"

	StartError();
	print("unexpected ");
	print(yyTokenName[yymajor]);
	EndError();
#line 2796 "parser.coh"
end sub;

# parse accept code
sub yy_accept() is
end sub;

sub ParserInit() is
	yyerrcnt := -1;
	yytos := &yystack[0];
	yystack[0].stateno := 0;
	yystack[0].major := 0;
end sub;

sub ParserDeinit() is
	while yytos != &yystack[0] loop
		yy_pop_parser_stack();
	end loop;
end sub;

sub ParserFeedToken(yymajor: YYCODETYPE, yyminor: [YYMINORTYPE]) is
	var yyact := yytos.stateno;

	#print("Input '");
	#print(yyTokenName[yymajor]);
	#if yyact < YY_MIN_REDUCE then
	#	print("' in state ");
	#	print_i16(yyact as uint16);
	#else
	#	print("' with pending reduce ");
	#	print_i16((yyact - YY_MIN_REDUCE) as uint16);
	#end if;
	#print_nl();

	loop
		if yyact <= YY_MAX_SHIFT then
			var i := yy_shift_ofst[yyact as @indexof yy_shift_ofst] + (yymajor as YYTOKENOFFSETTYPE);
			if yy_lookahead[i as @indexof yy_lookahead] != yymajor then
				yyact := yy_default[yyact as @indexof yy_default];
			else
				yyact := yy_action[i as @indexof yy_action];
			end if;
		end if;

		if yyact >= YY_MIN_REDUCE then
			yyact := yy_reduce(yyact - YY_MIN_REDUCE, yymajor);
		elseif yyact <= YY_MAX_SHIFTREDUCE then
			if yytos == &yystack[YYSTACKDEPTH] then
				yy_stack_overflow();
				return;
			end if;
			yytos := @next yytos;

			if yyact > YY_MAX_SHIFT then
				yyact := yyact + (YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE);
			end if;

			yytos.stateno := yyact;
			yytos.major := yymajor;
			CopyMinor(yyminor, &yytos.minor);
			#yy_trace_shift(yyact, "Shift");

			if yyerrcnt >= 0 then
				yyerrcnt := yyerrcnt - 1;
			end if;
			break;
		elseif yyact == YY_ACCEPT_ACTION then
			yytos := @prev yytos;
			yy_accept();
			break;
		else
			if yyerrcnt <= 0 then
				yy_syntax_error(yymajor, &yyminor.yy0);
			end if;
			yyerrcnt := 3;
			yy_destructor(yymajor, yyminor);
			if yymajor == 0 then
				yy_parse_failed();
				yyerrcnt := -1;
			end if;
			break;
		end if;
	
		if yytos == &yystack[0] then
			break;
		end if;
	end loop;
end sub;

