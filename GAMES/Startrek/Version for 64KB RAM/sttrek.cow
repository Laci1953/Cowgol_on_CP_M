#
# Super Star Trek Classic (v1.1)
# Retro Star Trek Game 
# C Port Copyright (C) 1996  <Chris Nystrom>
#
# Reworked for Fuzix by Alan Cox (C) 2018
#	- Removed all floating point
#	- Fixed multiple bugs in the BASIC to C conversion
#	- Fixed a couple of bugs in the BASIC that either got in during it's
#	  conversion between BASICs or from the original trek
#	- Put it on a diet to get it to run in 32K. No features were harmed
#	  in the making of this code smaller.
#
# Adapted for HiTech C on CP/M by Ladislau Szilagyi 2023
#
# Ported to Cowgol on CP/M by Ladislau Szilagyi 2024
#
# This program is free software; you can redistribute it and/or modify
# in any way that you wish. _Star Trek_ is a trademark of Paramount
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# This is a C port of an old BASIC program: the classic Super Star Trek
# game. It comes from the book _BASIC Computer Games_ edited by David Ahl
# of Creative Computing fame. It was published in 1978 by Workman Publishing,
# 1 West 39 Street, New York, New York, and the ISBN is: 0-89489-052-3.
# 
# See http://www.cactus.org/~nystrom/startrek.html for more info.
#
# Contact Author of C port at:
#
# Chris Nystrom
# 1013 Prairie Dove Circle
# Austin, Texas  78758
#
# E-Mail: cnystrom@gmail.com, nystrom@cactus.org
#
# BASIC -> Conversion Issues
#
#     - String Names changed from A$ to sA
#     - Arrays changed from G(8,8) to map[9][9] so indexes can
#       stay the same.
#
# Here is the original BASIC header:
#
# SUPER STARTREK - MAY 16, 1978 - REQUIRES 24K MEMORY
#
#**       **** STAR TREK ****        ****
#** SIMULATION OF A MISSION OF THE STARSHIP ENTERPRISE,
#** AS SEEN ON THE STAR TREK TV SHOW.
#** ORIGINAL PROGRAM BY MIKE MAYFIELD, MODIFIED VERSION
#** PUBLISHED IN DEC'S "101 BASIC GAMES", BY DAVE AHL.
#** MODIFICATIONS TO THE LATTER (PLUS DEBUGGING) BY BOB
#** LEEDOM - APRIL & DECEMBER 1974,
#** WITH A LITTLE HELP FROM HIS FRIENDS . . .
#** COMMENTS, EPITHETS, AND SUGGESTIONS SOLICITED --
#** SEND TO:  R. C. LEEDOM
#**           WESTINGHOUSE DEFENSE & ELECTRONICS SYSTEMS CNTR.
#**           BOX 746, M.S. 338
#**           BALTIMORE, MD  21203
#**
#** CONVERTED TO MICROSOFT 8 K BASIC 3/16/78 BY JOHN BORDERS
#** LINE NUMBERS FROM VERSION STREK7 OF 1/12/75 PRESERVED AS
#** MUCH AS POSSIBLE WHILE USING MULTIPLE STATMENTS PER LINE
#
#

@decl sub get_char(): (c: uint8) @extern("get_char");
@decl sub print_char(c: uint8) @extern("print_char");
@decl sub print(ptr: [uint8]) @extern("print");
@decl sub print_nl() @extern("print_nl");
@decl sub print_i16(v: int16) @extern("print_i16");
@decl sub isdigit(ch: uint8): (ret: uint8) @extern("isdigit");
@decl sub xrnd() :(ret: uint16) @extern("xrnd");
@decl sub itoa(i: int16): (pbuf: [uint8]) @extern("itoa");
@decl sub atoi(p: [uint8]): (ret: int16) @extern("atoi");

@decl sub strlen(str: [uint8]): (len: uint16) @extern("strlen");
@decl sub strcpy(dest: [uint8], src: [uint8]): (ret: [uint8]) @extern("strcpy");

record CpmFCB is
	dr: uint8;
	f: uint8[11];
	ex: uint8;
	s1: uint8;
	s2: uint8;
	rc: uint8;
	d: uint8[16];
	cr: uint8;
	r0: uint8;
	r1: uint8;
	r2: uint8;
end record;

record FCB is
	bufferptr: uint8; # offset in buffer
	iotype: uint8;
	datatype: uint8;
	cpm: CpmFCB;
	buffer: uint8[128];
end record;

# file types
const IO_TEXT := 0;

const ERR_EOF := 5;

@decl sub FCBOpenIn(fcb: [FCB], filename: [uint8], filetype: uint8): (errno: uint8) @extern("FCBOpenIn");
@decl sub FCBGetChar(fcb: [FCB]): (c: uint8, errno: uint8) @extern("FCBGetChar");
@decl sub FCBClose(fcb: [FCB]): (errno: uint8) @extern("FCBClose");

const MAP_VISITED := 0x1000;

const Q_SPACE :=	0;
const Q_STAR :=		1;
const Q_BASE :=		2;
const Q_KLINGON :=	3;
const Q_SHIP :=		4;

const CR := 0xD;

@decl sub get_kdata_x(n: uint8): (x: uint8) @extern("get_kdata_x");
@decl sub get_kdata_y(n: uint8): (y: uint8) @extern("get_kdata_y");
@decl sub get_ship_x(): (ret: int16) @extern("get_ship_x");
@decl sub get_ship_y(): (ret: int16) @extern("get_ship_y");
@decl sub set_kdata_x(n: uint8, x: uint8) @extern("set_kdata_x");
@decl sub set_kdata_y(n: uint8, y: uint8) @extern("set_kdata_y");
@decl sub set_base_x(v: uint8) @extern("set_base_x");
@decl sub set_base_y(v: uint8) @extern("set_base_y");
@decl sub get_quad(x: uint8, y: uint8): (ret: int8) @extern("get_quad");
@decl sub put_quad(x: uint8, y: uint8, val: int8) @extern("put_quad");
@decl sub set_damage(n: uint8, v:int16) @extern("set_damage");
@decl sub get_damage(n: uint8): (ret: int16) @extern("get_damage");
@decl sub get_klingons(): (ret: int8) @extern("get_klingons");
@decl sub get_docked(): (ret: int8) @extern("get_docked");
@decl sub get_kdata_energy(n: uint8): (energy: int16) @extern("get_kdata_energy");
@decl sub set_kdata_energy(n: uint8, energy: int16) @extern("set_kdata_energy");
@decl sub get_shield(): (ret: int16) @extern("get_shield");
@decl sub set_shield(v: int16) @extern("set_shield");
@decl sub ship_destroyed() @extern("ship_destroyed");
@decl sub get_quad_x(): (ret: uint8) @extern("get_quad_x");
@decl sub get_quad_y(): (ret: uint8) @extern("get_quad_y");
@decl sub get_torps(): (ret: int8) @extern("get_torps");
@decl sub set_torps(v: int8) @extern("set_torps");
@decl sub get_energy(): (ret: int16) @extern("get_energy");
@decl sub set_energy(v: int16) @extern("set_energy");
@decl sub torpedo_hit(yp: int8, xp: int8) @extern("torpedo_hit");
@decl sub set_klingons(v: int8) @extern("set_klingons");
@decl sub get_starbases(): (ret: int8) @extern("get_starbases");
@decl sub set_starbases(v: int8) @extern("set_starbases");
@decl sub get_stars(): (ret: int8) @extern("get_stars");
@decl sub set_stars(v: int8) @extern("set_stars");
@decl sub set_d4(v: int16) @extern("set_d4");
@decl sub get_time_start(): (ret: int16) @extern("get_time_start");
@decl sub get_stardate(): (ret: int16) @extern("get_stardate");
@decl sub quadrant_name(small:int8, y:uint8, x:uint8) @extern("quadrant_name");

sub TO_FIXED(x: int16): (ret: int16) @extern("TO_FIXED") is
	ret := x * 10;
end sub;

sub FROM_FIXED(x: int16): (ret: int16) @extern("FROM_FIXED") is
	ret := x / 10;
end sub;

sub TO_FIXED00(x: int16): (ret: int16) @extern("TO_FIXED00") is
	ret := x * 100;
end sub;

sub FROM_FIXED00(x: int16): (ret: int16) @extern("FROM_FIXED00") is
	ret := x / 100;
end sub;

#	Returns an integer from 1 to spread
sub get_rand(spread: uint16): (ret: uint16) @extern("get_rand") is
	var r: uint16;

	r := xrnd();
	ret := (r % spread) + 1;
end sub;

#	Get a random co-ordinate
sub rand8(): (ret: uint8) @extern("rand8") is
	ret := get_rand(8) as uint8;
end sub;

# An unsigned sqrt is all we need.
#   What we are actually doing here is a smart version of calculating n^2
#   repeatedly until we find the right one
sub isqrt(i:int16): (ret: int16) @extern("isqrt") is
	var b:int16 := 0x4000;
	var q:int16 := 0;
	var r:int16 := i;
	var t:int16;

	loop
		if b == 0 then
			break;
		end if;

		t := q + b;
		q := q >> 1;
		if r >= t then
			r := r - t;
			q := q + b;
		end if;
		b := b >> 2;
	end loop;
	ret := q;
end sub;

sub abs16(v: int16): (ret: uint16) @extern("abs16") is
	if v >= 0 then
		ret := v as uint16;
	else
		ret := -v as uint16;
	end if;
end sub;

sub abs32(v: int32): (ret: uint32) @extern("abs32") is
	if v >= 0 then
		ret := v as uint32;
	else
		ret := -v as uint32;
	end if;
end sub;

sub square00(t:int16): (ret:int16) @extern("square00") is
	if abs16(t) > 181 then
		t := t / 10;
		t := t * t;
	else
		t := t * t;
		t := t / 100;
	end if;
	ret := t;
end sub;

# Round off floating point numbers instead of truncating
sub cint100(d:int16): (ret:int16) @extern("cint100") is
	ret := (d + 50) / 100;
end sub;

#	Get a line from console (up to len bytes, until CR)
sub input(p: [uint8], len: uint8) @extern("input") is
	var c: uint8;
	while len != 0 loop
		c := get_char();
		if (c == CR) then
			break;
		end if;
		[p] := c; p := p + 1; len := len - 1;
	end loop;
	[p] := 0;
end sub;

sub yesno(): (ret: uint8) @extern("yesno") is
	var ch: uint8 := get_char();
	if (ch == 'y' or ch == 'Y') then
		ret := 1;
	else
		ret := 0;
	end if;
end sub;

var pbuf16:[uint8] := "                ";

# Input a value between 0.00 and 9.99 */
sub input_f00(): (ret: int16) @extern("input_f00") is
	var p: [uint8] := pbuf16;
	var ch: uint8;

	input(p, 8);

	if (isdigit([p]) == 0) then
		ret := -1;
		return;
	end if;

	ret := 100 * (([p] - '0') as int16); p := p + 1;

	if ([p] == 0) then
		return;
	end if;

	ch := [p]; p := p + 1;

	if (ch != '.') then
		ret := -1;
		return;
	end if;

	if (isdigit([p]) == 0) then
		ret := -1;
		return;
	end if;

	ret := ret + 10 * (([p] - '0') as int16); p := p + 1;

	if ([p] == 0) then
		return;
	end if;

	if (isdigit([p]) == 0) then
		ret := -1;
		return;
	end if;

	ret := ret + (([p] - '0') as int16);
end sub;

# Integer: unsigned, or returns -1 for blank
sub input_int(): (ret: int16) @extern("input_int") is
	var p: [uint8] := pbuf16;

	input(p, 8);

	if [p] == 0 then
		ret := -1;
	else
		ret := atoi(p);
	end if;
end sub;

sub print100(v: int16): (ret: [uint8]) @extern("print100") is
	var p: [uint8] := pbuf16;
	var q: [uint8];

	if v < 0 then
		v := -v;
		[p] := '-'; p := p + 1;
	end if;

	p := strcpy(p, itoa(v / 100));
	p := p + strlen(p);
	[p] := '.'; p := p + 1;
	q := itoa(v % 100);

	if (strlen(q) == 2) then
		p := strcpy(p, q);
	else
		[p] := '0'; p := p + 1; [p] := [q]; p := p + 1; [p] := 0;
	end if;

	ret := pbuf16;
end sub;

var device_name: [uint8][9] := {
	"                   ",
	"Warp engines       ",
	"Short range sensors",
	"Long range sensors ",
	"Phaser control     ",
	"Photon tubes       ",
	"Damage control     ",
	"Shield control     ",
	"Library computer   "
};

sub get_dev_name(n: uint8): (ret: [uint8]) @extern("get_dev_name") is
	if n < 0 or n > 8 then
		n := 0;
	end if;
	ret := device_name[n];
end sub;

# display text files ---------------------------------------------------

const MAXROW := 24;

var infcb: FCB;

# do not check record length...
sub fgets(buffer: [uint8], fcb: [FCB]): (eof: uint8) is
	var ch: uint8;
	var err: uint8;

	loop
		(ch, err) := FCBGetChar(fcb);

		if err == ERR_EOF then 
			eof := 1;
			return;
		end if;

		if ch == CR then 		# if is a CR,
			(ch, err) := FCBGetChar(fcb); 	# read also the next LF
			[buffer] := ch; 	#store only the LF
			buffer := buffer + 1;
			[buffer] := 0; 		#then store end-of-string
			eof := 0;
			return;
		else
			[buffer] := ch; buffer := buffer + 1;
		end if;		

	end loop;
end sub;

# we suppose that the files to be displayed have only lines shorter than 200 chars... 
record _buffer is
chars: uint8[200];
end record;

var buffer: _buffer;

sub showfile(filename:[uint8]) @extern("showfile") is
	var row: int16 := 0;
	var pbuffer: [uint8] := &buffer.chars[0];
	var dummy: uint8;

	if FCBOpenIn(&infcb, filename, IO_TEXT) != 0 then
		return;
	end if;
		
	while fgets(pbuffer, &infcb) == 0 loop
		print(pbuffer); 
		row := row + 1;
		if row > MAXROW - 3 then
			dummy := get_char();
			row := 0;
		end if;
	end loop;
	dummy := FCBClose(&infcb);
end sub;

#unsigned int map[9][9]		/* Galaxy. BCD of k b s plus flag */
# we have no two dimensional arrays, therefore...
var map: uint16[81];		# Galaxy 9x9. BCD of k b s plus flag

sub get_map(x: uint8, y: uint8): (ret: uint16) @extern("get_map") is
	ret := map[(y*9)+x];
end sub;

sub put_map(x: uint8, y: uint8, val: uint16) @extern("put_map") is
	map[(y*9)+x] := val;
end sub;

# Movement indices 1-9 (9 is wrap of 1)
#char c[3][10] =	/* Movement indices 1-9 (9 is wrap of 1) */
#{
#	{0},
#	{0, 0, -1, -1, -1, 0, 1, 1, 1, 0},
#	{1, 1, 1, 0, -1, -1, -1, 0, 1, 1}
#};
# 
# we have no two dimensional arrays, therefore...
var c: int8[30] := {0,0,0,0,0,0,0,0,0,0, 0,0,-1,-1,-1,0,1,1,1,0, 1,1,1,0,-1,-1,-1,0,1,1};

sub get_c(x: uint8, y: uint8): (ret: int16) @extern("get_c") is
	ret := c[(y*10)+x] as int16;
end sub;

# Return the distance to an object in x.xx fixed point 
sub distance_to(i:uint8): (ret:int16) @extern("distance_to") is
	# We do the squares in fixed point maths 
	ret := square00(TO_FIXED00(get_kdata_y(i) as int16) - get_ship_y());
	ret := ret + square00(TO_FIXED00(get_kdata_x(i) as int16) - get_ship_x());

	# Find the integer square root
	ret := isqrt(ret);

	# Correct back into 0.00 fixed point
	ret := ret * 10;
end sub;

# search for Q_SPACE
sub find_space(): (r1: uint8, r2: uint8) is
	loop
		r1 := rand8();
		r2 := rand8();
		if get_quad(r2 - 1, r1 - 1) == Q_SPACE then
			break;
		end if;
	end loop;
end sub;

# search for Q_SPACE & set-it Q_KLINGON
sub fs_empty_pl_k(i: uint8) is
	var r1: uint8;
	var r2: uint8;
	(r1, r2) := find_space();

	put_quad(r2 - 1, r1 - 1, Q_KLINGON);

	set_kdata_y(i, r1);
	set_kdata_x(i, r2);
end sub;

# search for Q_SPACE & set-it Q_BASE
sub fs_empty_pl_b() is
	var r1: uint8;
	var r2: uint8;
	(r1, r2) := find_space();

	put_quad(r2 - 1, r1 - 1, Q_BASE);

	set_base_y(r1);
	set_base_x(r2);
end sub;

# search for Q_SPACE & set-it Q_STAR
sub fs_empty_pl() is
	var r1: uint8;
	var r2: uint8;
	(r1, r2) := find_space();

	put_quad(r2 - 1, r1 - 1, Q_STAR);
end sub;

# returns 1 = inoperable, else 0
sub inoperable(u: uint8): (ret: uint8) @extern("inoperable") is
	var p: [uint8];
	if get_damage(u) < 0 then
		print(get_dev_name(u));
		print_char(' ');
		if u == 5 then
			p := "are ";
		else
			p := "is ";
		end if;
		print(p);
		print("inoperable.\n");
		ret := 1;
	else
		ret := 0;
	end if;
end sub;

var dcr: [uint8] := "Damage Control report:";

sub repair_damage(warp:int16) @extern("repair_damage") is
	var i:uint8;
	var d1:uint8 := 0;
	var repair_factor:int16;

	repair_factor := warp;

	if warp >= 100 then
		repair_factor := TO_FIXED00(1);
	end if;

	i := 1;
	while i <= 8 loop
		if get_damage(i) < 0 then
			set_damage(i, get_damage(i) + repair_factor);
			if get_damage(i) > -10 and get_damage(i) < 0 then
				set_damage(i, -10);
			elseif get_damage(i) >= 0 then
				if d1 != 1 then
					d1 := 1;
					print(dcr);
				end if;
				print("    ");
				print(get_dev_name(i));
				print(" repair completed\n\n");
				set_damage(i, 0);
			end if;
		end if;
		i := i + 1;
	end loop;

	if get_rand(10) <= 2 then
		var r:uint8 := rand8();

		if get_rand(10) < 6 then
			# Working in 1/100ths
			set_damage(r, get_damage(r) - ((get_rand(500) + 100) as int16));
			print(dcr);
			print("    ");
			print(get_dev_name(r));
			print(" damaged\n\n");
		else
			# Working in 1/100ths
			set_damage(r, get_damage(r) + (get_rand(300) as int16) + 100);
			print(dcr);
			print("    ");
			print(get_dev_name(r));
			print(" state of repair improved\n\n");
		end if;
	end if;
end sub;

sub klingons_shoot() @extern("klingons_shoot") is
	var h:uint32;
	var i:uint8;

	if get_klingons() <= 0 then
		return;
	end if;

	if get_docked() == 1 then
		print("Starbase shields protect the Enterprise\n\n");
		return;
	end if;

	i := 0;
	while i <= 2 loop
		if get_kdata_energy(i) > 0 then
			h := (get_kdata_energy(i) * (200 + get_rand(100) as int16)) as uint32;
			h := h * (100 as uint32);	# Ready for division in fixed 
			h := h / (distance_to(i) as uint32);
			h := abs32(h as int32);
			# Takes us back into FIXED00 */
			set_shield(get_shield() - FROM_FIXED00(h as int16));

			set_kdata_energy(i, (get_kdata_energy(i) * 100) / (300 + get_rand(100) as int16));

			print_i16(FROM_FIXED00(h as int16));
			print(" unit hit on Enterprise from sector ");
			print_i16(get_kdata_y(i) as int16);
			print(", ");
			print_i16(get_kdata_x(i) as int16);
			print_nl();	

			if get_shield() <= 0 then
				print_nl();
				ship_destroyed();
			end if;

			print("    <Shields down to ");
			print_i16(get_shield());
			print(" units>\n\n");

			if h >= 20 then
				# The check in basic is float and is h/s >.02. We
				#   have to use 32bit values here to avoid an overflow
				#   FIXME: use a better algorithm perhaps ? */
				var ratio:int32 := (h as int32) / (get_shield() as int32);
				if get_rand(10) <= 6 or ratio > 2 then
					var r:uint8 := rand8();
					# The original basic code computed h/s in
					#   float form the C conversion broke this. We correct it in the fixed
					#   point change
					set_damage(r, get_damage(r) - (ratio as int16 + get_rand(50) as int16));

					print("Damage Control reports\n   ");
					print(get_dev_name(r));
					print(" damaged by hit\n\n");
				end if;
			end if;
		end if;
		i := i + 1;
	end loop;
end sub;

sub wipe_klingon(i: uint8) @extern("wipe_klingon") is
	put_quad(get_kdata_x(i) - 1, get_kdata_y(i) - 1, Q_SPACE);
end sub;

sub klingons_move() @extern("klingons_move") is
	var i:uint8;

	i := 0;
	while i <= 2 loop
		if get_kdata_energy(i) > 0 then
			wipe_klingon(i);
			fs_empty_pl_k(i);
		end if;
		i := i + 1;
	end loop;

	klingons_shoot();
end sub;

sub put1bcd(v: int8) is
	v := v & 0x0F;
	print_char('0' + v as uint8);
end sub;

sub putbcd(x: int16) @extern("putbcd") is
	put1bcd((x >> 8) as int8);
	put1bcd((x >> 4) as int8);
	put1bcd(x as int8);
end sub;

var lrs_1:[uint8] := "-------------------\n";

sub l_range_scan() @extern("l_range_scan") is
	var i: uint8;
	var j: uint8;

	if inoperable(3) == 1 then
		return;
	end if;

	print("Long Range Scan for Quadrant ");
	print_i16(get_quad_y() as int16);
	print(", ");
	print_i16(get_quad_x() as int16);
	print("\n\n");

	i := get_quad_y() - 1;
	while i <= get_quad_y() + 1 loop
		print(lrs_1);
		j := get_quad_x() - 1;
		while j <= get_quad_x() + 1 loop
			print_char(' ');
			if i > 0 and i <= 8 and j > 0 and j <= 8 then
				put_map(j, i, get_map(j, i) | MAP_VISITED);
				putbcd(get_map(j, i) as int16);
			else
				print("***");
			end if;
			print(" :");
		j := j + 1;
		end loop;
		print_char('\n');
	i := i + 1;
	end loop;
	print(lrs_1);
	print_nl();
end sub;

sub photon_tor() @extern("photon_tor") is
	var x3:int16;
	var y3:int16;
	var c1:int16;
	var c2:int16;
	var c3:int16;
	var c4:int16;
	var x:int16;
	var y:int16;
	var x1:int16;
	var x2:int16;
	var p:int8;

	if get_torps() <= 0 then
		print("\nAll photon torpedoes expended\n");
		return;
	end if;

	if inoperable(5) == 1 then
		return;
	end if;

	print("\nCourse (0-9): ");

	c1 := input_f00();

	if c1 == 900 then
		c1 := 100;
	end if;

	if c1 < 100 or c1 >= 900 then
		print("\nEnsign Chekov reports:\n  Incorrect course data, sir!\n");
		return;
	end if;

	# FIXME: energy underflow check ?
	set_energy(get_energy() - 2);
	set_torps(get_torps() - 1);

	c2 := FROM_FIXED00(c1);		# Integer part
	c3 := c2 + 1;			# Next integer part 
	c4 := c1 - TO_FIXED00(c2);	# Fractional element in fixed point

	# x1 = 100 * c[1][c2] + (c[1][c3] - c[1][c2]) * c4;
	x1 := 100 * get_c(c2 as uint8, 1) + (get_c(c3 as uint8, 1) - get_c(c2 as uint8, 1)) * c4;

	# x2 = 100 * c[2][c2] + (c[2][c3] - c[2][c2]) * c4;
	x2 := 100 * get_c(c2 as uint8, 2) + (get_c(c3 as uint8, 2) - get_c(c2 as uint8, 2)) * c4;

	# The basic code is very confused about what is X and what is Y 
	x := get_ship_y() + x1;
	y := get_ship_x() + x2;

	x3 := FROM_FIXED00(x);
	y3 := FROM_FIXED00(y);

	print("\nTorpedo Track:\n");

	loop
		if x3 < 1 or x3 > 8 or y3 < 1 or y3 > 8 then
			break;
		end if;

		print("    ");
		print_i16(x3);
		print(", ");
		print_i16(y3);
		print_nl();		

		#p = quad([x3-1][y3-1]);
		p := get_quad(y3 as uint8 - 1, x3 as uint8 - 1);
		# In certain corner cases the first trace we'll step is
		#   ourself. If so treat it as space
		if p != Q_SPACE and p != Q_SHIP then 
			torpedo_hit(x3 as int8, y3 as int8);
			klingons_shoot();
			return;
		end if;

		x := x + x1;
		y := y + x2;

		x3 := FROM_FIXED00(x);
		y3 := FROM_FIXED00(y);
	end loop;

	print("Torpedo Missed\n\n");

	klingons_shoot();
end sub;

var quadname: [uint8] := "            ";	# Quadrant name

sub get_quadname(): (ret: [uint8]) @extern("get_quadname") is
ret := quadname;
end sub;

sub place_ship() @extern("place_ship") is
	put_quad(FROM_FIXED00(get_ship_x()) as uint8 - 1, FROM_FIXED00(get_ship_y()) as uint8 - 1, Q_SHIP);
end sub;

sub new_quadrant() @extern("new_quadrant") is
	var i: uint8;
	var j: uint8;
	var tmp: int16;

	set_klingons(0);
	set_starbases(0);
	set_stars(0);

	# Random factor for damage repair. We compute it on each new
	#   quadrant to stop the user just retrying until they get a number
	#   they like. The conversion here was wrong and now copies the BASIC
	#   code generate 0.00 to 0.49
	set_d4(get_rand(50) as int16 - 1);

	# Copy to computer 
	put_map(get_quad_x(), get_quad_y(), get_map(get_quad_x(), get_quad_y()) | MAP_VISITED);

	if get_quad_y() >= 1 and get_quad_y() <= 8 and get_quad_x() >= 1 and get_quad_x() <= 8 then
		quadrant_name(0, get_quad_y(), get_quad_x());

		if TO_FIXED(get_time_start()) != get_stardate() then
			print("Now entering "); 
		else 
			print("\nYour mission begins with your starship located\r\n\n");
			print("in the "); 
		end if;
		print(quadname); print(" quadrant...\n\n");
	end if;

	tmp := get_map(get_quad_x(), get_quad_y()) as int16;
	set_klingons(((tmp >> 8) & 0x0F) as int8);
	set_starbases(((tmp >> 4) & 0x0F) as int8);
	set_stars((tmp & 0x0F) as int8);

	if get_klingons() > 0 then
		print("Combat Area  Condition Red\n");

		if get_shield() < 200 then
			print("Shields Dangerously Low\n");
		end if;
	end if;

	i := 0;
	while i <= 2 loop
		set_kdata_y(i, 0);
		set_kdata_x(i, 0);
		set_kdata_energy(i, 0);
		i := i + 1;
	end loop;

	i := 0;
	while i < 8 loop
		j := 0;
		while j < 8 loop
			put_quad(i, j, Q_SPACE);
			j := j + 1;
		end loop;
		i := i + 1;
	end loop;

	place_ship();
	
	if get_klingons() > 0 then
		i := 0;
		while i < get_klingons() as uint8 loop
			fs_empty_pl_k(i);
			set_kdata_energy(i, 100 + get_rand(200) as int16);
			i := i + 1;
		end loop;
	end if;

	if get_starbases() > 0 then
		fs_empty_pl_b();
	end if;

	i := 1;
	while i <= get_stars() as uint8 loop
		fs_empty_pl();
		i := i + 1;
	end loop;
end sub;


