# 				COWFIX
#
# 		part of the Cowgol language compiler toolchain
# 			for Z80 based computers
#
# cowfix in_file out_file [-O] [-S]
#
# where
#
# O = optimize
# S = large stack
# in_file = Input: assembler source file build by Cowlink
# out_file = Output: assembler source file, modified for the purpose to:
# - be accepted by ZAS/Z80AS ( fix questionable syntax, e.g: 
#				'push h' instead of 'push hl'
#				'jr' instead of 'jp' as default )
# - drop non-used labels
# - drop useless statements
# - other optimizations
#
# 		Szilagyi Ladislau, 2023-2025
#
# Last version : v16, Sept 2025
#

const VERSION := 16;

include "misc.coh";
include "seqfile.coh";

# ----------------------------------------------------

# OPTIMIZATIONS COUNTERS

var LineCounter: uint16 := 0;
var labels_dropped: uint16 := 0;
var fixed_push: uint16 := 0;
var fixed_pop: uint16 := 0;
var fixed_jr: uint16 := 0;
var fixed_dword: uint16 := 0;
var returns_added: uint16 := 0;
var jump_to_jump: uint16 := 0;
var statements_group: uint16 := 0;
var long_db: uint16 := 0;
var dropped_ld: uint16 := 0;

# ----------------------------------------------------

# LIMITS

# max count of chars in the offset part for ws+offset (DO NOT CHANGE!)
const  OFFSET_SIZE := 5;

# maximum label size (DO NOT CHANGE!)
const  LABEL_SIZE := 8;

# maximum number of modules (.coo or .cow) used to build the input (byte)
const MAX_HEADERS_COUNT := 10;

# labels count limit (word)
const  MAX_LABELS_COUNT := 2000;

# end_xxx labels count limit (word)
const  MAX_ENDLABELS_COUNT := 200;

# (ld ws, ld ws, ret) groups count limit (byte)
const  MAX_LDLDRET := 50;

# ld r(r), (ws+nnnn) count limit (word)
const  MAX_REF_COUNT := 100;

# ld (ws+nnnn),rr count limit (word)
const  MAX_STORE_COUNT	:= 100;

# ld rr,(ws+nnnn) count limit (word)
const  MAX_LOAD_COUNT	:= 100;

# remove lines table capacity (word)
const  MAX_REMOVE_COUNT := 500;

# jp-to-jp table capacity (byte)
const  MAX_JP_TO_COUNT := 100;

# strings ----------------------------------------------------------------

sub strlen(str: [uint8]): (len: uint16) is
@asm "ld de,(", str, ")";
@asm "ld hl,0";
@asm "1:";
@asm "ld a,(de)";
@asm "or a";
@asm "ret z";
@asm "inc de";
@asm "inc hl";
@asm "jr 1b";
end sub;

sub strcpy(dest: [uint8], src: [uint8]) is
@asm "ld hl,(", src, ")";
@asm "ld de,(", dest, ")";
@asm "1:";
@asm "ld a,(hl)";
@asm "ld (de),a";
@asm "or a";
@asm "ret z";
@asm "inc hl";
@asm "inc de";
@asm "jr 1b";
@asm "ret";
end sub;

sub strncpy(dest: [uint8], src: [uint8], len: uint16) is
@asm "ld hl,(", src, ")";
@asm "ld de,(", dest, ")";
@asm "ld bc,(", len, ")";
@asm "1:";
@asm "ld a,(hl)";
@asm "ld (de),a";
@asm "or a";
@asm "ret z";
@asm "dec bc";
@asm "ld a,b";
@asm "or c";
@asm "inc hl";
@asm "inc de";
@asm "jr nz,1b";
@asm "ret";
end sub;

sub strcat(dest: [uint8], src: [uint8]) is
@asm "ld hl,(", src, ")";
@asm "ld de,(", dest, ")";
@asm "1:";
@asm "ld a,(de)";
@asm "inc de";
@asm "or a";
@asm "jr nz,1b";
@asm "dec de";
@asm "2:";
@asm "ld a,(hl)";
@asm "ld (de),a";
@asm "or a";
@asm "ret z";
@asm "inc hl";
@asm "inc de";
@asm "jr 2b";
end sub;

# returns 0 if equal, 1 if greather, else -1
sub strcmp(str1: [uint8], str2: [uint8]): (ret: int8) is
@asm "ld de,(", str1, ")";
@asm "ld hl,(", str2, ")";
@asm "1:";
@asm "ld a,(de)";
@asm "cp (hl)";
@asm "jr nz,2f";
@asm "or a";
@asm "ret z";
@asm "jr 3f";
@asm "2:";
@asm "jr nc,4f";
@asm "ld a,-1";
@asm "ret";
@asm "3:";
@asm "inc hl";
@asm "inc de";
@asm "jr 1b";
@asm "4:";
@asm "ld a,1";
@asm "ret";
end sub;

# returns 0 if equal, 1 if greather, else -1
sub strncmp(str1: [uint8], str2: [uint8], len: uint16): (ret: int8) is
@asm "ld de,(", str1, ")";
@asm "ld hl,(", str2, ")";
@asm "ld bc,(", len, ")";;
@asm "1:";
@asm "ld a,(de)";
@asm "cp (hl)";
@asm "jr nz,2f";
@asm "or a";
@asm "ret z";
@asm "jr 3f";
@asm "2:";
@asm "jr nc,4f";
@asm "ld a,-1";
@asm "ret";
@asm "3:";
@asm "inc hl";
@asm "inc de";
@asm "dec bc";
@asm "ld a,b";
@asm "or c";
@asm "ret z";
@asm "jr 1b";
@asm "4:";
@asm "ld a,1";
@asm "ret";
end sub;

sub strstr(str: [uint8], tosearch: [uint8]): (ret: [uint8]) is
@asm "ld de,(", tosearch, ")";
@asm "ld hl,(", str, ")";
@asm "1:";
@asm "ld a,(de)";
@asm "cp (hl)";
@asm "jr z,2f";
@asm "inc hl";
@asm "ld a,(hl)";
@asm "or a";
@asm "jr nz,1b";
@asm "3:";
@asm "ld hl,0";
@asm "ret";
@asm "2:";
@asm "ld b,d";
@asm "ld c,e";
@asm "inc de";
@asm "ld a,(de)";
@asm "or a";
@asm "ret z";
@asm "push hl";
@asm "inc hl";
@asm "6:";
@asm "ld a,(de)";
@asm "cp (hl)";
@asm "jr nz,4f";
@asm "inc hl";
@asm "inc de";
@asm "ld a,(de)";
@asm "or a";
@asm "jr z,5f";
@asm "ld a,(hl)";
@asm "or a";
@asm "jr nz,6b";
@asm "pop hl";
@asm "jr 3b";
@asm "5:";
@asm "pop hl";
@asm "ret";
@asm "4:";
@asm "pop hl";
@asm "inc hl";
@asm "ld a,(hl)";
@asm "or a";
@asm "jr z,3b";
@asm "ld d,b";
@asm "ld e,c";
@asm "jr 1b";
end sub;

var ret_strstr: [uint8];

#keeps returned pointer in ret_strstr
sub _strstr(str: [uint8], tosearch: [uint8]): (ret: [uint8]) is
@asm "ld de,(", tosearch, ")";
@asm "ld hl,(", str, ")";
@asm "1:";
@asm "ld a,(de)";
@asm "cp (hl)";
@asm "jr z,2f";
@asm "inc hl";
@asm "ld a,(hl)";
@asm "or a";
@asm "jr nz,1b";
@asm "3:";
@asm "ld hl,0";
@asm "ret";
@asm "2:";
@asm "ld b,d";
@asm "ld c,e";
@asm "inc de";
@asm "ld a,(de)";
@asm "or a";
@asm "jr z,9f";
@asm "push hl";
@asm "inc hl";
@asm "6:";
@asm "ld a,(de)";
@asm "cp (hl)";
@asm "jr nz,4f";
@asm "inc hl";
@asm "inc de";
@asm "ld a,(de)";
@asm "or a";
@asm "jr z,5f";
@asm "ld a,(hl)";
@asm "or a";
@asm "jr nz,6b";
@asm "pop hl";
@asm "jr 3b";
@asm "5:";
@asm "pop hl";
@asm "9:ld (", ret_strstr, "),hl";
@asm "ret";
@asm "4:";
@asm "pop hl";
@asm "inc hl";
@asm "ld a,(hl)";
@asm "or a";
@asm "jr z,3b";
@asm "ld d,b";
@asm "ld e,c";
@asm "jr 1b";
end sub;

sub strchr(str: [uint8], tosearch: uint8): (ret: [uint8]) is
@asm "ld a,(", tosearch, ")";
@asm "ld c,a";
@asm "ld hl,(", str, ")";
@asm "1:";
@asm "ld a,c";
@asm "cp (hl)";
@asm "ret z";
@asm "inc hl";
@asm "ld a,(hl)";
@asm "or a";
@asm "jr nz,1b";
@asm "ld hl,0";
@asm "ret";
end sub;

sub rindex(p: [uint8], ch: uint8): (ret: [uint8]) is
 @asm " ld a,(", ch, ")";
 @asm " ld e,a";
 @asm " ld bc,0";
 @asm " jr 5f";
 @asm "6:inc hl";
 @asm " inc bc";
 @asm "5:ld a,(hl)";
 @asm " or a";
 @asm " jr nz,6b";
 @asm "1:dec hl";
 @asm " ld a,c";
 @asm " or b";
 @asm " jr z,2f";
 @asm " dec bc";
 @asm " ld a,(hl)";
 @asm " cp e";
 @asm " jr nz,1b";
 @asm " ret";
 @asm "2:ld hl,0";
 @asm " ret";
end sub;

# misc utility routines --------------------------------------------------

var ret_IsLabelRef: [uint8];

# keep returned pointer in ret_IsLabelRef
sub IsLabelRef(p:[uint8]): (ret: [uint8]) is
     #find first 'jr'
 @asm " ld a,(hl)";
 @asm " cp 10";  #empty line?
 @asm " jr z,3f";
 @asm " cp 9";  #first char must be 9
 @asm " jr nz,3f";
 @asm " inc hl";
 @asm " ld a,(hl)"; #second must be 'j'
 @asm " cp 'j'";
 @asm " jr nz,3f";
 @asm " inc hl";  #skip 'j'
 @asm " inc hl";  #skip next 'r'
 @asm " inc hl";  #skip next blank
 @asm " ld a,(hl)"; #should be 'c'
 @asm " cp 'e'";  #if endf ref, ret NULL
 @asm " jr z,3f";
 @asm " cp 'c'";
 @asm " jr nz,1f";  #try the flags
     #first char is 'c' ,
 @asm " inc hl";  #may be label ref, or 'c,'
 @asm " ld a,(hl)"; #check first 'c,'
 @asm " cp ','";
 @asm " jr z,2f";  #try skiping flags
 @asm " dec hl"; 
 @asm "9: ld (", ret_IsLabelRef, "),hl";
 @asm " ret";   #HL=pointer of label
     #its a 'jr x(x), ' look for ','
     #HL is pointing 'x(x), '
 @asm "1:inc hl";  #pointing '(x), '
 @asm " ld a,(hl)";
 @asm " cp ','";
 @asm " jr z,2f";  #it was ', '
 @asm " inc hl";  #no, skip next 'x'
 @asm "2:inc hl";  #skip ','
 @asm " inc hl";  #skip blank, now pointing label ref
 @asm " ld a,(hl)";
 @asm " cp 'c'";  #check first 'c'
 @asm " jr z,9b";  #HL=pointer of label
     #should not happen...
 @asm "3:ld hl,0";
 @asm " ret";
end sub;

var ret_IsEndLabelRef: [uint8];

# keep returned pointer in ret_IsEndLabelRef
sub IsEndLabelRef(p:[uint8]): (ret: [uint8]) is
     #find first 'jr'
 @asm " ld a,(hl)";
 @asm " cp 10";  #empty line?
 @asm " jr z,3f";
 @asm " cp 9";  #first char must be 9
 @asm " jr nz,3f";
 @asm " inc hl";
 @asm " ld a,(hl)"; #second must be 'j'
 @asm " cp 'j'";
 @asm " jr nz,3f";
 @asm " inc hl";  #skip 'j'
 @asm " inc hl";  #skip next 'r'
 @asm " inc hl";  #skip next blank
 @asm " ld a,(hl)"; #should be 'e'
 @asm " cp 'e'";  #check first 'e'
 @asm " jr z,9f";  #HL=pointer of end label
     #no, may be label ref, or 'x(x), '
 @asm " cp 'c'";
 @asm " jr nz,1f";
 @asm " inc hl";
 @asm " ld a,(hl)";
 @asm " cp ','";
 @asm " dec hl";
 @asm " jr nz,3f";  #its a label ref...
     #its a 'jr x(x), ' look for ','
     #HL is pointing 'x(x), '
 @asm "1:inc hl";  #pointing '(x), '
 @asm " ld a,(hl)";
 @asm " cp ','";
 @asm " jr z,2f";  #it was ', '
 @asm " inc hl";  #no, skip next 'x'
 @asm "2:inc hl";  #skip ','
 @asm " inc hl";  #skip blank, now pointing (end)label ref
 @asm " ld a,(hl)";
 @asm " cp 'e'";  #check first 'e'
 @asm " jr z,9f";  #HL=pointer of end label 
     #should not happen...
 @asm "3:ld hl,0";
 @asm " ret";
 @asm "9: ld (", ret_IsEndLabelRef, "),hl";
 @asm " ret";
end sub;

sub ZeroFill(p: [uint8]) is
 @asm "  ld a,'0'";
 @asm "  ld b,5";
 @asm " fillz: ld (hl),a";
 @asm "  inc hl";
 @asm "  djnz fillz";
 @asm "  ld (hl),0";
 @asm "  ret";
end sub;

# move from src to dest len chars, from last to first
sub Move(dest: [uint8], src: [uint8], len: uint16) is
  dest := dest + len;
  src := src + len;

  [dest] := 0;

  while len > 0 loop
    src := @prev src;
    dest := @prev dest;

    [dest] := [src];
    len := len - 1;
  end loop;
end sub;

# comment out the line
sub CommentOut(s: [uint8]) is
  Move(s+1, s, strlen(s));
  [s] := ';';
end sub;

# File I/O related -----------------------------

sub FCBDelete(fcb: [FCB]) is
	var cpmfcb := &fcb.cpm;
	@asm "ld c, 19"; # DELETE_FILE
	@asm "ld de, (", cpmfcb, ")";
	@asm "call 5";
end sub;

# do not check record length...
sub fgets(buffer: [uint8], fcb: [FCB]): (eof: uint8) is
	var ch: uint8;
	var err: uint8;

	loop
		(ch, err) := FCBGetChar(fcb);
		
		if err == ERR_EOF then 
			eof := 1;
			return;
		end if;

		[buffer] := ch; 
		buffer := @next buffer;

		if ch == 0xA then 			# if is a LF,
			[buffer] := 0; 			# then store end-of-string
			eof := 0;
			return;
		end if;		
	end loop;
end sub;

sub fputs(buffer: [uint8], fcb: [FCB]): (err: uint8) is
	var ch:uint8;

	loop
		ch := [buffer];

		if ch == 0 then
			err := 0;
			return;
		end if;

		buffer := @next buffer;

		err := FCBPutChar(fcb, ch);
		if err != 0 then
			return;
		end if;
	end loop;
end sub;

# -----------------------------

var Optimize: uint8 := 0;
var BigStack: uint8 := 0;

var in: FCB;
var out: FCB;

var buf1: uint8[512];
var buf2: uint8[512];
var buf3: uint8[512];
var buf: uint8[64];
var s: [uint8];
var p: [uint8];
var q: [uint8];
var tmp: [uint8];
var tmp8: uint8;
var v: uint8;

var Workspace: uint8[OFFSET_SIZE+1];	# current subroutine workspace
var CrtSubIndex: uint16;		# index of the current subroutine
var InSubroutine: uint8;		# 1 if inside a subroutine
var WaitingRet: uint8;			# 1 if end_fnnn: was identified
var AfterCallCounter: uint8;		# used to count statements after a call statement

# Pass 1 ---------------------------------------------------------------------------------

#- Optimization of 
#
#-------------------------------------------
#
#	ld (ws+nnn),hl
#end_fyyy:
#	ld hl,(ws+nnn)
#	ret
#
#-->	ret
#
#-------------------------------------------
#
#	ld (ws+nnn),a
#end_fyyy:
#	ld a,(ws+nnn)
#	ret
#
#-->	ret
#
#-------------------------------------------

var LdLdRet: uint16[MAX_LDLDRET];
var LdLdRetCount: uint8 := 0;

var ldwshlnnn: uint8[OFFSET_SIZE+1];			# nnn from ld (ws+nnn),hl
var ldwshl_Line: uint16;
var ldhlws: uint8 := 0;					# 1: ld hl,(ws+nnn) found
var ldhlwsnnn: uint8[OFFSET_SIZE+1];			# nnn from ld hl,(ws+nnn)

var ldwsannn: uint8[OFFSET_SIZE+1];			# nnn from ld (ws+nnn),a
var ldwsa_Line: uint16;
var ldaws: uint8 := 0;					# 1: ld a,(ws+nnn) found
var ldawsnnn: uint8[OFFSET_SIZE+1];			# nnn from ld a,(ws+nnn)

sub SearchLdLdRet(line: uint16): (ret: uint8) is
  var n: uint8 := 0;
  
  #print("Searching LdLdRet for line ");
  #print(itoa(line as int16));
  #print_nl();

  while n < LdLdRetCount loop
    if LdLdRet[n] == line then

      #print("...found\n");

      ret := 1;
      return;
    end if;
    n := n + 1;
  end loop;

  #print("...not found\n");

  ret := 0;
end sub;

sub SaveLdLdRet(line: uint16) is
  if LdLdRetCount == MAX_LDLDRET then
    print("Too many LdLdRet structures!\n");
    exit();
  end if;

  #print("Saving LdLdRet for line ");
  #print(itoa(line as int16));
  #print_nl();

  LdLdRet[LdLdRetCount] := line;
  LdLdRetCount := LdLdRetCount + 1;
end sub;

#- Optimization of store statements ------------------------------------------------------
#
# Eliminate 'ld (ws+nnn), hl' or 'ld (ws+nnn), a' statements
# if nnn is not used in 'ld hl,(ws+nnn)' statements of the current subroutine, or
#    nnn or nnn+1 is not used in 'ld a,(ws+nnn)' statements of the current subroutine

var EndLabels: uint8[MAX_ENDLABELS_COUNT * (LABEL_SIZE+1)];	#endlabels : end_fnnn
var EndLabelsCount: uint16 := 0;
var EndLabelsPtr: [uint8] := &EndLabels[0];

sub AddEndLabel(endlabel: [uint8]) is
  if EndLabelsCount == MAX_ENDLABELS_COUNT then
    print("Too many jp to end_f!\n");
    exit();
  end if;

  # keep only 8 chars
  strncpy(EndLabelsPtr, endlabel, LABEL_SIZE);
  EndLabelsPtr := EndLabelsPtr + LABEL_SIZE;
  [EndLabelsPtr] := 0;
  EndLabelsPtr := EndLabelsPtr + 1;
  EndLabelsCount := EndLabelsCount + 1;

  #print("Added EndLabel ");
  #print(endlabel);
  #print_nl();

end sub;

sub SearchEndLabel(label: [uint8]): (ret: uint8) is
  var n: uint16 := 0;
  var p: [uint8] := &EndLabels[0];

  #print("Searching EndLabel ");
  #print(label);
  #print_nl();

  while n < EndLabelsCount loop
    if strncmp(p, label, LABEL_SIZE) == 0 then

      #print("...found\n");

      ret := 1;
      return;
    end if;
    n := n + 1;
    p := p + LABEL_SIZE + 1;
  end loop;

  #print("...not found\n");

  ret := 0;
end sub;

# ---------------------------------------------------------------------------------

var NormalizedAscii: uint8[OFFSET_SIZE+1];

# ld r(r), (ws+nnnn) where nnnn < Workspace
var RefsA: uint8[MAX_REF_COUNT * (OFFSET_SIZE+1)];
var CrtRefsAIndex: uint16 := 0;
var CrtRefsAPtr: [uint8] := &RefsA[0];

var RefsRR: uint8[MAX_REF_COUNT * (OFFSET_SIZE+1)];
var CrtRefsRRIndex: uint16 := 0;
var CrtRefsRRPtr: [uint8] := &RefsRR[0];

var StoreA: uint8[MAX_STORE_COUNT * (OFFSET_SIZE+1)];
var CrtStoreAIndex: uint16;
var CrtStoreAPtr: [uint8];

var StoreRR: uint8[MAX_STORE_COUNT * (OFFSET_SIZE+1)];
var CrtStoreRRIndex: uint16;
var CrtStoreRRPtr: [uint8];

var LoadA: uint8[MAX_LOAD_COUNT * (OFFSET_SIZE+1)];
var CrtLoadAIndex: uint16;
var CrtLoadAPtr: [uint8];

var LoadRR: uint8[MAX_LOAD_COUNT * (OFFSET_SIZE+1)];
var CrtLoadRRIndex: uint16;
var CrtLoadRRPtr: [uint8];

record toremove is
  SubNr: uint16;
  Ascii: uint8[OFFSET_SIZE+1];
end record;

var ToRemove: toremove[MAX_REMOVE_COUNT];
var CrtToRemoveIndex: uint16;
var CrtToRemovePtr: [uint8];

sub Normalize(Ascii: [uint8]): (ret: [uint8]) is
  var len: uint16;
  var pd: [uint8];

  len := 0;

  while isdigit([Ascii]) == 1 loop
    Ascii := @next Ascii;
    len := len + 1;
  end loop;

  Ascii := @prev Ascii;
  pd := &NormalizedAscii[0] + OFFSET_SIZE - 1;

  ZeroFill(&NormalizedAscii[0]);

  while len > 0 loop
    [pd] := [Ascii];
    pd := @prev pd;
    Ascii := @prev Ascii; 
    len := len - 1;
  end loop;

  ret:= &NormalizedAscii[0];
end sub;

sub SearchInStoreA(Ascii: [uint8]): (ret: uint8) is
  var n: uint16 := 0;
  var p: [uint8] := &StoreA[0];

  #print("Search in StoreA ");
  #print(Ascii);
  #print_nl();

  while n < CrtStoreAIndex loop
    if strcmp(p, Ascii) == 0 then

      #print("...found\n");

      ret := 1;
      return;
    end if;
    n := n + 1;
    p := p + OFFSET_SIZE+1;
  end loop;

  #print("...not found\n");

  ret := 0;
end sub;

sub PutInStoreA(Ascii: [uint8]) is
  #print("PutInStoreA called for ");
  #print(Ascii);
  #print_nl();

  if SearchInStoreA(Ascii) == 0 then
    if CrtStoreAIndex == MAX_STORE_COUNT then
      print("Too many storeAs!\n");
      exit();
    end if;

    strcpy(CrtStoreAPtr, Ascii);

    CrtStoreAIndex := CrtStoreAIndex + 1;
    CrtStoreAPtr := CrtStoreAPtr + OFFSET_SIZE+1;

    #print(Ascii);
    #print(" was stored!");
    #print_nl();
  end if;
end sub;

sub SearchInStoreRR(Ascii: [uint8]): (ret: uint8) is
  var n: uint16 := 0;
  var p: [uint8] := &StoreRR[0];

  #print("Search in StoreRR ");
  #print(Ascii);
  #print_nl();

  while n < CrtStoreRRIndex loop
    if strcmp(p, Ascii) == 0 then

      #print("...found\n");

      ret := 1;
      return;
    end if;
    n := n + 1;
    p := p + OFFSET_SIZE+1;
  end loop;

  #print("...not found\n");

  ret := 0;
end sub;

sub PutInStoreRR(Ascii: [uint8]) is
  #print("PutInStoreRR called for ");
  #print(Ascii);
  #print_nl();

  if SearchInStoreRR(Ascii) == 0 then
    if CrtStoreRRIndex == MAX_STORE_COUNT then
      print("Too many storeRRs!\n");
      exit();
    end if;

    strcpy(CrtStoreRRPtr, Ascii);

    CrtStoreRRIndex := CrtStoreRRIndex + 1;
    CrtStoreRRPtr := CrtStoreRRPtr + OFFSET_SIZE+1;

    #print(Ascii);
    #print(" was stored!");
    #print_nl();
  end if;
end sub;

sub SearchInLoadA(Ascii: [uint8]): (ret: uint8) is
  var n: uint16 := 0;
  var p: [uint8] := &LoadA[0];

  #print("Search in LoadA ");
  #print(Ascii);
  #print_nl();

  while n < CrtLoadAIndex loop
    if strcmp(p, Ascii) == 0 then

      #print("...found\n");

      ret := 1;
      return;
    end if;
    n := n + 1;
    p := p + OFFSET_SIZE+1;
  end loop;

  #print("...not found\n");

  ret := 0;
end sub;

sub PutInLoadA(Ascii: [uint8]) is
  #print("PutInLoadA called for ");
  #print(Ascii);
  #print_nl();

  if SearchInLoadA(Ascii) == 0 then
    if CrtLoadAIndex == MAX_LOAD_COUNT then
      print("Too many loadAs!\n");
      exit();
    end if;

    strcpy(CrtLoadAPtr, Ascii);

    CrtLoadAIndex := CrtLoadAIndex + 1;
    CrtLoadAPtr := CrtLoadAPtr + OFFSET_SIZE+1;

    #print(Ascii);
    #print(" was stored!");
    #print_nl();
  end if;
end sub;

sub SearchInLoadRR(Ascii: [uint8]): (ret: uint8) is
  var n: uint16 := 0;
  var p: [uint8] := &LoadRR[0];

  #print("Search in LoadRR ");
  #print(Ascii);
  #print_nl();

  while n < CrtLoadRRIndex loop
    if strcmp(p, Ascii) == 0 then

      #print("...found\n");

      ret := 1;
      return;
    end if;
    n := n + 1;
    p := p + OFFSET_SIZE+1;
  end loop;

  #print("...not found\n");

  ret := 0;
end sub;

sub PutInLoadRR(Ascii: [uint8]) is
  #print("PutInLoadRR called for ");
  #print(Ascii);
  #print_nl();

  if SearchInLoadRR(Ascii) == 0 then
    if CrtLoadRRIndex == MAX_LOAD_COUNT then
      print("Too many loadRRs!\n");
      exit();
    end if;

    strcpy(CrtLoadRRPtr, Ascii);

    CrtLoadRRIndex := CrtLoadRRIndex + 1;
    CrtLoadRRPtr := CrtLoadRRPtr + OFFSET_SIZE+1;

    #print(Ascii);
    #print(" was stored!");
    #print_nl();
  end if;
end sub;

sub SearchInToRemove(subnr: uint16, ascii: [uint8]): (ret: uint8) is
  var n: uint16 := 0;
  var p: [uint8] := &ToRemove[0].Ascii[0];

  #print("Search in ToRemove ");
  #print(itoa(subnr as int16));
  #print_char(' ');
  #print(ascii);
  #print_nl();

  while n < CrtToRemoveIndex loop
    if ToRemove[n].SubNr == subnr and strcmp(p, ascii) == 0 then

      #print("...found\n");

      ret := 1;
      return;
    end if;
    n := n + 1;
    p := &ToRemove[n].Ascii[0];
  end loop;

  #print("...not found\n");

  ret := 0;
end sub;

sub PutInToRemove(subnr: uint16, ascii: [uint8]) is
  if SearchInToRemove(subnr, ascii) == 0 then
    if CrtToRemoveIndex == MAX_REMOVE_COUNT then
      print("Too many removes!\n");
      exit();
    end if;

    ToRemove[CrtToRemoveIndex].SubNr := subnr;
    strcpy(CrtToRemovePtr, ascii);

    #print("Put in ToRemove ");
    #print(itoa(subnr as int16));
    #print_char(' ');
    #print(ascii);
    #print_nl();

    CrtToRemoveIndex := CrtToRemoveIndex + 1;
    CrtToRemovePtr := &ToRemove[CrtToRemoveIndex].Ascii[0];
  end if;
end sub;

sub SearchInRefsA(Ascii: [uint8]): (ret: uint8) is
  var n: uint16 := 0;
  var p: [uint8] := &RefsA[0];

  #print("Search in RefsA ");
  #print(Ascii);
  #print_nl();

  while n < CrtRefsAIndex loop
    if strcmp(p, Ascii) == 0 then

      #print("...found\n");

      ret := 1;
      return;
    end if;
    n := n + 1;
    p := p + OFFSET_SIZE+1;
  end loop;

  #print("...not found\n");

  ret := 0;
end sub;

sub PutInRefsA(Ascii: [uint8]) is
  if SearchInRefsA(Ascii) == 0 then
    if CrtRefsAIndex == MAX_REF_COUNT then
      print("Too many refsA!\n");
      exit();
    end if;

    strcpy(CrtRefsAPtr, Ascii);

    #print("PutInRefsA ");
    #print(Ascii);
    #print_nl();

    CrtRefsAIndex := CrtRefsAIndex + 1;
    CrtRefsAPtr := CrtRefsAPtr + OFFSET_SIZE+1;
  end if;
end sub;

sub SearchInRefsRR(Ascii: [uint8]): (ret: uint8) is
  var n: uint16 := 0;
  var p: [uint8] := &RefsRR[0];

  #print("Search in RefsRR ");
  #print(Ascii);
  #print_nl();

  while n < CrtRefsRRIndex loop
    if strcmp(p, Ascii) == 0 then

      #print("...found\n");

      ret := 1;
      return;
    end if;
    n := n + 1;
    p := p + OFFSET_SIZE+1;
  end loop;

  #print("...not found\n");

  ret := 0;
end sub;

sub PutInRefsRR(Ascii: [uint8]) is
  if SearchInRefsRR(Ascii) == 0 then
    if CrtRefsRRIndex == MAX_REF_COUNT then
      print("Too many refsRR!\n");
      exit();
    end if;

    strcpy(CrtRefsRRPtr, Ascii);

    #print("PutInRefsRR ");
    #print(Ascii);
    #print_nl();

    CrtRefsRRIndex := CrtRefsRRIndex + 1;
    CrtRefsRRPtr := CrtRefsRRPtr + OFFSET_SIZE+1;
  end if;
end sub;

#- PASS 1+2 Removal of unused labels ---------------------------------------------------------------

record labels is
  label: uint8[LABEL_SIZE+1];
  refs: uint8;		# references count
  beforeRet: uint8;	# 1:a 'ret' statement is the next statement
end record;

record labels_header is
  txt: uint8[2];
  first_index: uint16;
  count: uint16;
end record;

var crt_h: uint8 := 0;
var headers: labels_header[MAX_HEADERS_COUNT];

var Labels: labels[MAX_LABELS_COUNT];
var LabelsCount: uint16 := 0;

# return -1 if not found
sub SearchLabel(label: [uint8], terminator: uint8): (ret: int16) is
  var len: uint16;
  var hdr_index: uint8;
  var p: [uint8];
  var count: uint16;
  var hdr1: uint8;
  var hdr2: uint8;
  
  #print("Searching label ");

  if LabelsCount == 0 then
    #print("... but LabelsCount is 0!\n");
    ret := -1;
    return;
  end if;

  len := 0; #compute label len
  p := label;

  while [p] != terminator loop
    #print_char([p]);
    len := len + 1;
    p := @next p;
  end loop;

  #print_nl();

  # search label header (second & third chars)
  hdr_index := 0;
  p := label + 1;
  hdr1 := [p];
  p := @next p;
  hdr2 := [p];
   
  loop
    if hdr1 == headers[hdr_index].txt[0] and hdr2 == headers[hdr_index].txt[1] then
      break;
    end if;
    if crt_h == hdr_index then
      #print("not found header ");
      #print_char(hdr1);
      #print_char(hdr2);
      #print_nl();
      ret := -1;
      return;
    end if;
    hdr_index := hdr_index + 1;
  end loop;  

  #print("found header nr.");
  #print_i16(hdr_index as int16);
  #print_nl();

  ret := headers[hdr_index].first_index as int16; #search from here
  count := headers[hdr_index].count;	 #search counter

  p := &Labels[ret as uint16].label[0];

  while count > 0 loop
    if strncmp(label, p, len) == 0 then
      #print("found label!\n");
      return;
    end if;
    count := count - 1;
    ret := ret + 1;
    p := &Labels[ret as uint16].label[0];
  end loop;

  #print("not found label!\n");

  ret := -1;
end sub;

sub AddLabel(label: [uint8]) is
  var len: uint16 := 0;
  var n: int16;
  var p: [uint8];
  var hdr1: uint8;
  var hdr2: uint8;

  n := SearchLabel(label, 0xA);

  if n == -1 then
    if LabelsCount == MAX_LABELS_COUNT then
      print("Too many local labels!\n");
      exit();
    end if;

    #print("defining label ");
    p := label;

    # compute label len
    while [p] != 0xA loop
      #print_char([p]);
      len := len + 1;
      p := @next p;
    end loop;

    #print_nl();

    p := label + 1;
    hdr1 := [p];
    p := @next p;
    hdr2 := [p];

    if LabelsCount > 0 then
      #see if new header needed
      if hdr1 != headers[crt_h].txt[0] or hdr2 != headers[crt_h].txt[1] then
        #save new header
        if crt_h == MAX_HEADERS_COUNT-1 then
          print("Too many modules!\n");
          exit();
        end if;
        #print("define new header ");
        #print_char(hdr1);
        #print_char(hdr2);
        #print_nl();
        crt_h := crt_h + 1;
	headers[crt_h].first_index := LabelsCount;
	headers[crt_h].count := 0;
      end if;
    end if;

    if headers[crt_h].count == 0 then
      #set current header
      #print("define current header ");
      #print_char(hdr1);
      #print_char(hdr2);
      #print_nl();
      headers[crt_h].txt[0] := hdr1;
      headers[crt_h].txt[1] := hdr2;
    end if;

    headers[crt_h].count := headers[crt_h].count + 1;

    p := &Labels[LabelsCount].label[0];
    strncpy(p, label, len);
    p := p + len;
    [p] := 0;
    Labels[LabelsCount].refs := 1;
    Labels[LabelsCount].beforeRet := 0;

    LabelsCount := LabelsCount + 1;
  else
    Labels[n as uint16].refs := Labels[n as uint16].refs + 1;
  end if;
end sub;

# ----------------------------------------------------------------
# PASS 1 - identify real labels (those used in ld, dw, jp or call statements)
# ----------------------------------------------------------------

var allowCommentEndLabel: uint8 := 0;

sub BuildLabelTable() is
  var n: uint16;
  var tmps: uint8[OFFSET_SIZE+1];
  var isA: uint8;

  CrtToRemoveIndex := 0;
  CrtToRemovePtr := &ToRemove[0].Ascii[0];
  CrtSubIndex := 0;
  InSubroutine := 0;
  WaitingRet := 0;
  AfterCallCounter := 0;
  #Endf = 0;

  while fgets(&buf1[0], &in) == 0 loop

    s := &buf1[0];
    LineCounter := LineCounter + 1;

    #print("line ");
    #print(itoa(LineCounter as int16));
    #print_char(' ');
    #print(s);

    p := strstr(s, "ld hl,c");					# ld hl,cxxx_nnnn

    if p != nil then
      AddLabel(p+6);

    elseif _strstr(s, "dw c") != nil then			# dw cxxx_nnnn
      AddLabel(ret_strstr + 3);

    elseif IsEndLabelRef(s) != nil then
      AddEndLabel(ret_IsEndLabelRef);

    elseif IsLabelRef(s) != nil then				# jp [xx,] cxx_nnnn
      AddLabel(ret_IsLabelRef);

    elseif InSubroutine == 1 then				# inside subroutine
      isA := 0;

      if [s] == 'e' then					# end_fxxx
        WaitingRet := 1;
        if SearchEndLabel(s) == 0 then				# if end_f label was used, do not allow commenting-it
          allowCommentEndLabel := 1;
        end if;

      elseif strstr(s, "\tcall ") != nil then
        AfterCallCounter := 3;					#setup checking the two following statements

      elseif strstr(s, "ld (") != nil then 			# ld (..
        p := strstr(s, "ws+");

        if p != nil then					#ld (ws+nnn),
          tmp := Normalize(p + 3);

          if strchr(p, 'a') != nil then				#ld (ws+nnn),a
            isA := 1;
            strcpy(&ldwsannn[0], &NormalizedAscii[0]);
            ldwsa_Line := LineCounter;
          elseif strstr(p, "hl") != nil then			#ld (ws+nnn),hl
            strcpy(&ldwshlnnn[0], &NormalizedAscii[0]);
            ldwshl_Line := LineCounter;
          end if;

          if AfterCallCounter > 0 then
            if isA == 1 then
              PutInStoreA(&NormalizedAscii[0]);			#ld (ws+nnnn),a
            else
              PutInStoreRR(&NormalizedAscii[0]);		#ld (ws+nnnn),rr
            end if;
          end if;
        end if;

      elseif strchr(s, ',') != nil and _strstr(s, "ws+") != nil and strstr(s, "ld ") != nil then
        tmp := Normalize(ret_strstr + 3);			#ld       ,(ws+nnn)

        if strstr(s, " a") != nil then 				#ld a,(ws+nnn)
          isA := 1; 
          if strcmp(&NormalizedAscii[0], &Workspace[0]) < 0 then
            PutInRefsA(&NormalizedAscii[0]);			# it's a reference to an external variable
          else
            PutInLoadA(&NormalizedAscii[0]);
          end if;
        else							#ld rr,(ws+nnn)
          if strcmp(&NormalizedAscii[0], &Workspace[0]) < 0 then
            PutInRefsRR(&NormalizedAscii[0]);			# it's a reference to an external variable
          else
            PutInLoadRR(&NormalizedAscii[0]);
          end if;
        end if;

        if allowCommentEndLabel == 1 then
          if strstr(s, "hl") != nil then			#ld hl,(ws+nnn)
            if strcmp(&NormalizedAscii[0], &ldwshlnnn[0]) == 0 and ldwshl_Line == LineCounter - 2 then
              ldhlws := 1;
            end if;
          elseif isA == 1 then					#ld a,(ws+nnn)
            if strcmp(&NormalizedAscii[0], &ldwsannn[0]) == 0 and ldwsa_Line == LineCounter - 2 then
              ldaws := 1;
            end if;
          end if;
        end if;

      elseif WaitingRet == 1 and strstr(s, "\tret") != nil then

        if ldhlws == 1 then
          SaveLdLdRet(ldwshl_Line);
          ldhlws := 0;
        elseif ldaws == 1 then
          SaveLdLdRet(ldwsa_Line);
          ldaws := 0;
        end if;

        WaitingRet := 0;

        #print("end sub\n");

        n := 0;
        var psA: [uint8] := &StoreA[0];
        while n < CrtStoreAIndex loop
          if strcmp(psA, &Workspace[0]) >= 0 and SearchInLoadA(psA) == 0 and SearchInLoadRR(psA) == 0 and SearchInRefsA(psA) == 0 then
            PutInToRemove(CrtSubIndex, psA);
          end if;
          n := n + 1;
          psA := psA + OFFSET_SIZE+1;
        end loop;

        n := 0;
        var psRR: [uint8] := &StoreRR[0];
        while n < CrtStoreRRIndex loop
          if strcmp(psRR, &Workspace[0]) >= 0 and SearchInLoadRR(psRR) == 0 and SearchInLoadA(psRR) == 0 and SearchInRefsRR(psRR) == 0 then
            PutInToRemove(CrtSubIndex, psRR);
          end if;
          n := n + 1;
          psRR := psRR + OFFSET_SIZE+1;
        end loop;

        InSubroutine := 0;

      end if;

    # InSubroutine

    elseif strstr(s, "__main") == nil and strstr(s, "workspace at ") != nil then	# workspace at ws+nnn...
      InSubroutine := 1;
      CrtSubIndex := CrtSubIndex + 1;
      CrtStoreAIndex := 0;
      CrtStoreRRIndex := 0;
      CrtStoreAPtr := &StoreA[0];
      CrtStoreRRPtr := &StoreRR[0];
      CrtLoadAIndex := 0;
      CrtLoadRRIndex := 0;
      CrtLoadAPtr := &LoadA[0];
      CrtLoadRRPtr := &LoadRR[0];
      CrtRefsAIndex := 0;
      CrtRefsRRIndex := 0;
      CrtRefsAPtr := &RefsA[0];
      CrtRefsRRPtr := &RefsRR[0];
      allowCommentEndLabel := 0;
      p := strstr(s, "ws+") + 3;
      strcpy(&Workspace[0], Normalize(p));

      #print("Workspace ");
      #print(&Workspace[0]);
      #print_nl();

    end if; # if p != nil

    if AfterCallCounter > 0 then
      AfterCallCounter := AfterCallCounter - 1;
    end if;

  end loop;

end sub;

# ----------------------------------------------------------------
# Pass 2
# ----------------------------------------------------------------

@decl sub AddJp(From: uint16, To: uint16);

var LabelList: uint16[10];	#indexes in Labels for successive labels
var LabelListIndex: uint8 := 0;

# returns 3 = conserve LabelListIndex, 2 = skip this line, 1 = break(quit reading file), else 0
sub CheckLine(s: [uint8]): (ret: uint8) is
  var l: int32;
  var low: int16;
  var high: int16;
  var n: int16;
  var to: int16;

  ret := 0;

  #print("CheckLine\n");

  #detect "TOP:"
  if strncmp(s, "TOP:", 4) == 0 then
    ret := 1;
    return;
  end if;

  # push, pop b,d,h ---> push, pop bc,de,hl
  p := strstr(s, "\tp");
  if p != nil then
    p := p + 2;
    if strncmp(p, "ush ", 4) == 0 then
      p := p + 4;
      if [p] == 'b' then
        p := @next p;
        if [p] != 'c' then
          fixed_push := fixed_push + 1;
          [p] := 'c';
          p := @next p;
          [p] := '\n';
          p := @next p;
          [p] := 0;
          return;
        end if;
      elseif [p] == 'd' then
        p := @next p;
        if [p] != 'e' then
          fixed_push := fixed_push + 1;
          [p] := 'e';
          p := @next p;
          [p] := '\n';
          p := @next p;
          [p] := 0;
          return;
        end if;
      elseif [p] == 'h' then
        p := @next p;
        if [p] != 'l' then
          fixed_push := fixed_push + 1;
          [p] := 'l';
          p := @next p;
          [p] := '\n';
          p := @next p;
          [p] := 0;
          return;
        end if;
      end if;
    elseif strncmp(p, "op ", 3) == 0 then
      p := p + 3;
      if [p] == 'b' then
        p := @next p;
        if [p] != 'c' then
          fixed_pop := fixed_pop + 1;
          [p] := 'c';
          p := @next p;
          [p] := '\n';
          p := @next p;
          [p] := 0;
          return;
        end if;
      elseif [p] == 'd' then
        p := @next p;
        if [p] != 'e' then
          fixed_pop := fixed_pop + 1;
          [p] := 'e';
          p := @next p;
          [p] := '\n';
          p := @next p;
          [p] := 0;
          return;
        end if;
      elseif [p] == 'h' then
        p := @next p;
        if [p] != 'l' then
          fixed_pop := fixed_pop + 1;
          [p] := 'l';
          p := @next p;
          [p] := '\n';
          p := @next p;
          [p] := 0;
          return;
        end if;
      end if;
    end if;
  end if;

  # handle labels
  p := strchr(s, ':');
  if p != nil then			# look for labels with size > 31 ...
    if (p - s) > 31 then 		# label size > 31, truncate-it to 31 chars
      q := s + 31;
      [q] := ':';
      q := q + 1;
      while q <= p loop
        [q] := ' ';
        q := q + 1;
      end loop;
    end if;

    if Optimize == 0 then
      return;
    end if;
  end if;

  # handle jr's
  p := strstr(s, "\tjr ");		#(in cowgol.coo, the jr $+3 is prefixed by BLANKS...)
  if p != nil then
    fixed_jr := fixed_jr + 1;

    p := p + 2;				#jr ---> jp
    [p] := 'p';
					#what kind of jp?
    q := strchr(p, ',');
    if q != nil then
      q := q + 2;			#jp cond,label , skip to first char of label
    else
      q := p + 2;			#jp label , skip to first char of label
    end if;   

    if strlen(q) > 31 then		# label size > 31, truncate-it to 31 chars
      q := q + 31;
      if ([q] >= '0' and [q] <= '9') or ([q] >= 'A' and [q] <= 'z') or [q] == '_' then
        [q] := ';';
      end if;
    end if;

    if Optimize == 0 then
      return;
    end if;
  end if;

  # handle call's
  p := strstr(s, "\tcall ");
  if p != nil then
					#what kind of call?
    q := strchr(p, ',');
    if q != nil then
        q := q + 2;			#jp cond,label , skip to first char of label
    else
        q := p + 6;			#jp label , skip to first char of label
    end if;
     
    if strlen(q) > 31 then		# label size > 31, truncate-it to 31 chars
      q := q + 31;
      if ([q] >= '0' and [q] <= '9') or ([q] >= 'A' and [q] <= 'z') or [q] == '_' then
        [q] := ';';
      end if;
    end if;

    if Optimize == 0 then
      return;
    end if;
  end if;

  p := strstr(s, "add ");
  if p != nil then
    p := p + 4;
    if [p] != 'a' and [p] != 'h' then
				#add nnn ---> add a,nnn
      Move(p+2, p, strlen(p));
      [p] := 'a';
      p := @next p; 
      [p] := ',';
    end if;
   
    if Optimize == 0 then
      return;
    end if;
  end if;

  p := strstr(s, "adc ");
  if p != nil then
    p := p + 4;
    if [p] != 'a' and [p] != 'h' then
				#adc nnn ---> adc a,nnn
      Move(p+2, p, strlen(p));
      [p] := 'a';
      p := @next p; 
      [p] := ',';
    end if;
   
    if Optimize == 0 then
      return;
    end if;
  end if;

  p := strstr(s, "0x");
  if p != nil then		#0xNN ---> 0NNh
    p := p + 3;
    tmp8 := [p];   
    [p] := 'h';
    p := p - 1;
    v := [p];
    [p] := tmp8;
    p := p - 1;
    [p] := v;
    return;
  end if;

  if _strstr(s, "dword") != nil then
    # change dword n32 to dw low(n32), high(n32)
    fixed_dword := fixed_dword + 1;
    q := strchr(ret_strstr, ' ');
    q := q + 1;
    p := strchr(q, 0xA);
    [p] := 0;
    l := atol(q);
    low := l as int16;
    high := (l >> 16) as int16;
    strcpy(s, "defw ");
    strcat(s, itoa(low));
    strcat(s, ", ");
    strcat(s, itoa(high));
    strcat(s, "\n");
    tmp := strchr(s, '\n');
    tmp := tmp + 1;
    [tmp] := 0;
    return;
  end if;

  p := strstr(s, "LOMEM");
  if p != nil then
    tmp8 := fputs("\tglobal __Hbss\n", &out);
    strcpy(p, "__Hbss\n");
    return;
  end if;

  if Optimize == 0 then
    return;
  end if;
  
  # optimizations...

  if strncmp(s, "end_f", 5) == 0 then
    InSubroutine := 0;
    if SearchEndLabel(s) == 0 then
      ret := 2;
      return;
    end if;
  end if;

  if strstr(s, "__main") == nil and strstr(s, "workspace at ") != nil then	# workspace at ws+nnn...
    InSubroutine := 1;
    CrtSubIndex := CrtSubIndex + 1;
  end if;
     
  if InSubroutine == 1 then
    p := strstr(s, "ld (");
    if p != nil then
      p := strstr(p, "ws+");
      p := p + 3;
      tmp := Normalize(p);
      if strcmp(&NormalizedAscii[0], "00000") != 0 and SearchInToRemove(CrtSubIndex, &NormalizedAscii[0]) == 1 then
        ret := 2;
        return;
      end if;
    end if;
  end if;

  if [s] == 'c' then					# label
    n := SearchLabel(s, ':');
    if n == -1 then					# if not referenced, comment current line...
      labels_dropped := labels_dropped + 1;
      #print("dropping label ");
      #print(s);
      #print_nl();

      ret := 2;
      return; 		
    else
      #print("Adding ");
      #print(itoa(n));
      #print(" to LabelList\n");

      LabelList[LabelListIndex] := n as uint16;
      LabelListIndex := LabelListIndex + 1;
      ret := 3;
    end if;

  elseif strchr(s, ',') == nil and _strstr(s, "\tjp c") != nil then	# jp cxx_nnnn
    to := SearchLabel(ret_strstr+4, 0xA);
    tmp8 := 0;
    while tmp8 < LabelListIndex loop
      AddJp(LabelList[tmp8], to as uint16);
      tmp8 := tmp8 + 1;
    end loop;

  elseif [s] != ';' and strstr(s, "\tret") != nil then	# ret
    tmp8 := 0;
    while tmp8 < LabelListIndex loop

      #print("Setting label ");
      #print(&Labels[LabelList[tmp8]].label[0]);
      #print(" as placed before RET\n");

      Labels[LabelList[tmp8]].beforeRet := 1;
      tmp8 := tmp8 + 1;
    end loop;
  end if;
end sub;

# ----------------------------------------------------------------
# Pass 3 
# ----------------------------------------------------------------

# - Optimizations for
#
#---------------------------------
#
#	jp nz, cxx_xxxx
#	jp cxx_yyyy
#cxx_xxxx:
#
#-->	jp z, cxx_yyyy
#
#---------------------------------
#
#	jp z, cxx_xxxx
#	jp cxx_yyyy
#cxx_xxxx:
#
#-->	jp nz, cxx_yyyy
#
#---------------------------------
#
#	jp z, cxx_xxxx
#	call fyyy
#cxx_xxxx:
#
#-->	call nz,fyyy
#
#--------------------------------
#
#	jp nz, cxx_xxx
#	call fyyy
#cxx_xxx:
#
#-->	call z,fyyy
#
#--------------------------------
#
#	jp nz, cxx_xxx
#	ret
#cxx_xxx:
#
#-->	ret z
#
#--------------------------------
#
#	jp z, cxx_xxx
#	ret
#cxx_xxx:
#
#-->	ret nz
#
#--------------------------------

record jpto is
  From: uint16; 	#index in Labels
  To: uint16; 		#index in Labels
end record;

var JpTo: jpto[MAX_JP_TO_COUNT];
var JpToIndex: uint8 := 0;

@impl sub AddJp is
  if JpToIndex == MAX_JP_TO_COUNT then
    print("Too many JpTo...\n");
    exit();
  end if;

  #print("Add to Jp table : from ");
  #print(&Labels[From].label[0]);
  #print(" to ");
  #print(&Labels[To].label[0]);
  #print_nl();

  JpTo[JpToIndex].From := From;
  JpTo[JpToIndex].To := To;

  JpToIndex := JpToIndex + 1;
end sub;

# replaced by a C reentrant routine
#
# returns last To in the chain jp -> jp ... -> jp
#sub SearchJp(target: uint16): (ret: uint16) is
#  var n: uint8 := 0;
#
#  printf("Search in Jp table for %s\n", Labels[target].label);
#  while n < JpToIndex loop
#    if JpTo[n].From == target then
#      ret := SearchJp(JpTo[n].To);
#      return;
#    end if;
#    n := n + 1;
#  end loop;
#  
#  printf("...returns %s\n", Labels[target].label);
#  ret := target;
#end sub;

sub WRITE123() is
  tmp8 := fputs(&buf1[0], &out);
  tmp8 := fputs(&buf2[0], &out);
  tmp8 := fputs(&buf3[0], &out);
end sub;

sub WRITE12() is
  tmp8 := fputs(&buf1[0], &out);
  tmp8 := fputs(&buf2[0], &out);
end sub;

sub WRITE1() is
  tmp8 := fputs(&buf1[0], &out);
end sub;

sub Write123Commented() is
  statements_group := statements_group + 1;

  CommentOut(&buf1[0]);
  tmp8 := fputs(&buf1[0], &out);

  CommentOut(&buf2[0]);
  tmp8 := fputs(&buf2[0], &out);

  CommentOut(&buf3[0]);
  tmp8 := fputs(&buf3[0], &out);
end sub;

# returns 1 if jp was handled, else 0
# s points to the currect line
sub HandleJp(): (ret: uint8) is
 var xx: uint8[3];
 var to1: uint16;
 var to2: uint16;

 q := IsLabelRef(s);

 if q != nil then
   strcpy(&buf[0], q);

   to1 := SearchLabel(q, 0xA) as uint16;

   #to2 := SearchJp(to1);

   #print("Search in Jp table for ");
   #print(q);
   #print_nl();

   # call C routine int SearchJp(int target, struct _jpto *jpto, int counter)
   # search for to1, returns t02
   #
   @asm "ld hl,(", JpToIndex, ")";
   @asm "ld h,0";
   @asm "push hl";
   @asm "ld hl,", JpTo;
   @asm "push hl";
   @asm "ld hl,(", to1, ")";
   @asm "push hl";
   @asm "call _SearchJp";
   @asm "pop bc";
   @asm "pop bc";
   @asm "pop bc";
   @asm "ld (", to2, "),hl";

   #print("...returns ");
   #print(&Labels[to2].label[0]);
   #print_nl();

   xx[0] := 0;

   if Labels[to2].beforeRet != 0 then		# jp to ret !
     strcpy(&buf[0], s);

     p := strstr(s, "\tjp ");

     if strchr(s, ',') != nil then		# jp xx, cyy_xxxx
       p := p + 4;
       xx[0] := [p]; 
       p := p + 1;

       if [p] == ',' then
         xx[1] := 0;
       else
         xx[1] := [p];
         xx[2] := 0;
       end if;
     end if;

     returns_added := returns_added + 1;
     strcpy(s, "\tret ");
     strcat(s, &xx[0]);    
     strcat(s, " ;");
     strcat(s, &buf[0]);
     WRITE1();
     ret := 1;
     return;
   elseif to1 != to2 then			# jp target changed!
     jump_to_jump := jump_to_jump + 1;
     strcpy(q, &Labels[to2].label[0]);
     strcat(q, " ; ");
     strcat(q, &buf[0]);
     #strcat(q, "\n");
     WRITE1();
     ret := 1;
     return;
   end if;
 end if;

 ret := 0;
end sub;

var jpz: uint8 := 0;		# =1 if jp z,cxx_nnnn found
var jpzaddr: uint8[16];
var jpnz: uint8 := 0;		# =1 if jp nz,cxx_nnnn found
var jpnzaddr: uint8[16];

var jp: uint8 := 0;		# =1 if jp cxx_nnnn found
var jpaddr: uint8[16];

var addr: uint8[16];
var fyyy: uint8[64];

sub Pass3() is
 if HandleJp() != 0 then
   return;
 end if;

 p := strstr(&buf1[0], "jp nz, c");

 if p != nil then
   if Labels[SearchLabel(p+7, 0xA) as uint16].refs == 1 then
     strncpy(&jpnzaddr[0], p+7, LABEL_SIZE);
     jpnzaddr[LABEL_SIZE] := 0;
     tmp8 := fgets(&buf2[0], &in);

     p := strstr(&buf2[0], "\tjp c");

     if rindex(&buf2[0], ',') == nil and p != nil then
       strncpy(&jpaddr[0], p+4, LABEL_SIZE);
       jpaddr[LABEL_SIZE] := 0;
       tmp8 := fgets(&buf3[0], &in);

       if buf3[0] == 'c' and rindex(&buf3[0], ':') != nil then
         strncpy(&addr[0], &buf3[0], LABEL_SIZE);
         addr[LABEL_SIZE] := 0;

         if strcmp(&addr[0], &jpnzaddr[0]) == 0 then
           Write123Commented();
           #write 'jp z,jpaddr'
           strcpy(&buf[0], "\tjp z,");
           strcat(&buf[0], &jpaddr[0]);
           strcat(&buf[0], "\n");
           tmp8 := fputs(&buf[0], &out);
         else
           WRITE123();
         end if;
       else
         WRITE123();
       end if;

       return;
     end if;

     p := strstr(&buf2[0], "\tcall f");

     if p != nil then
       Move(&fyyy[0], p+6, strlen(p+6)-1);
       fyyy[strlen(p+6) as uint8 - 1] := 0;
       tmp8 := fgets(&buf3[0], &in);

       if buf3[0] == 'c' and rindex(&buf3[0], ':') != nil then
         strncpy(&addr[0], &buf3[0], LABEL_SIZE);
         addr[LABEL_SIZE] := 0;

         if strcmp(&addr[0], &jpnzaddr[0]) == 0 then
           Write123Commented();
           #write 'call z,fyyy'
           strcpy(&buf[0], "\tcall z,");
           strcat(&buf[0], &fyyy[0]);
           strcat(&buf[0], "\n");
           tmp8 := fputs(&buf[0], &out);
         else
           WRITE123();
         end if;
       else
         WRITE123();
       end if;

       return;
     end if;

     p := strstr(&buf2[0], "\tret");

     if p != nil then
       tmp8 := fgets(&buf3[0], &in);

       if buf3[0] == 'c' and rindex(&buf3[0], ':') != nil then
         strncpy(&addr[0], &buf3[0], LABEL_SIZE);
         addr[LABEL_SIZE] := 0;

         if strcmp(&addr[0], &jpnzaddr[0]) == 0 then
           Write123Commented();
           #write 'ret z'
           strcpy(&buf[0], "\tret z");
           strcat(&buf[0], "\n");
           tmp8 := fputs(&buf[0], &out);
         else
           WRITE123();
         end if;
       else
         WRITE123();
       end if;
     else
       WRITE12();
     end if;
   else
     WRITE1();
   end if;

   return;
 end if;

 p := strstr(&buf1[0], "jp z, c");

 if p != nil then
   if Labels[SearchLabel(p+6, 0xA) as uint16].refs == 1 then
     strncpy(&jpzaddr[0], p+6, LABEL_SIZE);
     jpzaddr[LABEL_SIZE] := 0;
     tmp8 := fgets(&buf2[0], &in);

     p := strstr(&buf2[0], "\tjp c");

     if p != nil and rindex(&buf2[0], ',') == nil then
       strncpy(&jpaddr[0], p+4, LABEL_SIZE);
       jpaddr[LABEL_SIZE] := 0;
       tmp8 := fgets(&buf3[0], &in);

       if buf3[0] == 'c' and rindex(&buf3[0], ':') != nil then
         strncpy(&addr[0], &buf3[0], LABEL_SIZE);
         addr[LABEL_SIZE] := 0;
         if strcmp(&addr[0], &jpzaddr[0]) == 0 then
           Write123Commented();
           #write 'jp nz,jpaddr'
           strcpy(&buf[0], "\tjp nz,");
           strcat(&buf[0], &jpaddr[0]);
           strcat(&buf[0], "\n");
           tmp8 := fputs(&buf[0], &out);
         else
           WRITE123();
         end if;
       else
         WRITE123();
       end if;

       return;
     end if;

     p := strstr(&buf2[0], "\tcall f");

     if p != nil then
       Move(&fyyy[0], p+6, strlen(p+6)-1);
       fyyy[strlen(p+6) as uint8 - 1] := 0;
       tmp8 := fgets(&buf3[0], &in);

       if buf3[0] == 'c' and rindex(&buf3[0], ':') != nil then
         strncpy(&addr[0], &buf3[0], LABEL_SIZE);
         addr[LABEL_SIZE] := 0;

         if strcmp(&addr[0], &jpzaddr[0]) == 0 then
           Write123Commented();
           #write 'call nz,fyyy'
           strcpy(&buf[0], "\tcall nz,");
           strcat(&buf[0], &fyyy[0]);
           strcat(&buf[0], "\n");
           tmp8 := fputs(&buf[0], &out);
         else
           WRITE123();
         end if;
       else
         WRITE123();
       end if;

       return;
     end if;
   
     p := strstr(&buf2[0], "\tret");

     if p != nil then
       tmp8 := fgets(&buf3[0], &in);

       if buf3[0] == 'c' and rindex(&buf3[0], ':') != nil then
         strncpy(&addr[0], &buf3[0], LABEL_SIZE);
         addr[LABEL_SIZE] := 0;

         if strcmp(&addr[0], &jpzaddr[0]) == 0 then
           Write123Commented();
           #write 'ret nz'
           strcpy(&buf[0], "\tret nz");
           strcat(&buf[0], "\n");
           tmp8 := fputs(&buf[0], &out);
         else
           WRITE123();
         end if;
       else
         WRITE123();
       end if;
     else
       WRITE12();
     end if;
   else
     WRITE1();
   end if;
 else
   WRITE1();
 end if;
end sub;

var n: uint8;
var filein: [uint8];
var fileout: [uint8];
var oOptimize: [uint8];
var oBigStack: [uint8];

headers[0].first_index := 0;
headers[0].count := 0;

ArgvInit();
filein := ArgvNext();
fileout := ArgvNext();
oOptimize := ArgvNext();
oBigStack := ArgvNext();

if oOptimize != nil then Optimize := 1; end if;
if oBigStack != nil then BigStack := 1; end if;

if filein == nil or fileout == nil then
  print("Invalid parameters!\nUsage is: cowfix in_file out_file [-O] [-S]\n");
  exit();
end if;

if FCBOpenIn(&in, filein, IO_TEXT) != 0 then
  print("Cannot open input file!\n");
  exit();
end if;

if Optimize == 1 then
  if FCBOpenOut(&out, "cowfix.$$$", IO_TEXT) != 0 then
    print("Cannot open output file!\n");
    exit();
  end if;
else
  if FCBOpenOut(&out, fileout, IO_TEXT) != 0 then
    print("Cannot open output file!\n");
    exit();
  end if;
end if;

print("COWFIX v");
print_i8(VERSION);
print(" fixing syntax");
if Optimize == 1 then print(" and optimizing code"); end if;
print_nl();

if Optimize == 1 then
  # First pass : gather labels related info & load/store related info

  print("PASS 1\n");

  BuildLabelTable();

  # Second pass : apply optimizations #1

  print("PASS 2\n");

  InSubroutine := 0;
  CrtSubIndex := 0;
  LineCounter := 0;

  if FCBRewind(&in) != 0 then
    print("Cannot rewind input file!\n");
    exit();
  end if;
end if;

tmp8 := fgets(&buf1[0], &in); #skip "org 100h"
LineCounter := LineCounter + 1;
tmp8 := fgets(&buf1[0], &in); #skip "lxi sp,TOP+128"
LineCounter := LineCounter + 1;

tmp8 := fputs("\tpsect text\n", &out); #write "psect text"
tmp8 := fputs("\tld sp,TOPSTACK\n", &out); #write first line

while fgets(&buf1[0], &in) == 0 loop
  s := &buf1[0];

  LineCounter := LineCounter + 1;

  #print("line ");
  #print(itoa(LineCounter as int16));
  #print_char(' ');
  #print(s);

  if strncmp(s, "\tdw ", 4) == 0 then
					# dw --> defw
    Move(s+6, s+4, strlen(s+2));
    p := s + 2;
    [p] := 'e';
    p := @next p;
    [p] := 'f';
    p := @next p;
    [p] := 'w';
    p := @next p;
    [p] := ' ';

    if Optimize == 1 then
        LabelListIndex := 0;
    end if;

    tmp8 := fputs(&buf1[0], &out);

    continue;
  end if;

  if strncmp(s, "\tdb", 3) == 0 then
					# db ---> defb
    Move(s+6, s+4, strlen(s+2));
    p := s + 2;
    [p] := 'e';
    p := @next p;
    [p] := 'f';
    p := @next p;
    [p] := 'b';
    p := @next p;
    [p] := ' ';
					# handle too long db statements
    while strlen(&buf1[0]) > 128 loop
      long_db := long_db + 1;

      p := &buf1[0] + 128;

      while [p] != ',' loop
        p := p - 1;			# find first previous ','
      end loop;
					# then split line
      strcpy(&buf2[0], "\tdefb ");
      strcat(&buf2[0], p+1);

      [p] := '\n';
      p := p + 1;
      [p] := 0;

      tmp8 := fputs(&buf1[0], &out);
      strcpy(&buf1[0], &buf2[0]);
    end loop;

    tmp8 := fputs(&buf1[0], &out);

    if Optimize == 1 then
        LabelListIndex := 0;
    end if;

    continue;
  end if;

  if Optimize == 1 and SearchLdLdRet(LineCounter) == 1 then	
    					# drop 3 lines, keep only the next 'ret'
    dropped_ld := dropped_ld + 2;

    #print("Dropping out 3 lines at line ");
    #print(itoa(LineCounter as int16));
    #print_nl();

    #print(&buf1[0]);

    tmp8 := fgets(&buf1[0], &in);
    LineCounter := LineCounter + 1;

    #print(&buf1[0]);

    tmp8 := fgets(&buf1[0], &in);
    LineCounter := LineCounter + 1;

    #print(&buf1[0]);

    tmp8 := fgets(&buf1[0], &in);
    LineCounter := LineCounter + 1;
    tmp8 := fputs(&buf1[0], &out);		# ret

    LabelListIndex := 0;
    continue;
  end if;

  n := CheckLine(s);

  if n == 0 and Optimize == 1 then
    LabelListIndex := 0;
  elseif n == 1 then
    break;
  elseif n == 2 then
    continue;
  end if;

  tmp8 := fputs(&buf1[0], &out);
end loop;

tmp8 := fputs("\tglobal _exit\n", &out);
tmp8 := fputs("_exit: rst 0\n", &out);

tmp8 := fgets(&buf1[0], &in); #skip "ws equ TOP+128"
tmp8 := fgets(&buf1[0], &in); #read "LOMEM equ ws+..."

tmp8 := fputs("\tpsect data\n", &out);
tmp8 := fputs("ws:\n", &out);

strcpy(&buf2[0], "\tdefs ");
strcat(&buf2[0], &buf1[0]+13);
tmp8 := fputs(&buf2[0], &out);

tmp8 := fputs("\tpsect bss\n", &out);

if BigStack == 1 then
  tmp8 := fputs("\tdefs 1024\n", &out);
else
  tmp8 := fputs("\tdefs 128\n", &out);
end if;

tmp8 := fputs("TOPSTACK:\n", &out);

tmp8 := FCBClose(&in);
tmp8 := FCBClose(&out);

if Optimize == 1 then
  # Third pass : apply optimizations #2

  print("PASS 3\n");

  tmp8 := FCBOpenIn(&in, "cowfix.$$$", IO_TEXT);
  tmp8 := FCBOpenOut(&out, fileout, IO_TEXT);

  LineCounter := 1;

  while fgets(&buf1[0], &in) == 0 loop
    s := &buf1[0];

    #print("line ");
    #print(itoa(LineCounter as int16));
    #print_char(' ');
    #print(s);
    LineCounter := LineCounter + 1;

    #skip commented lines
    if [s] != ';' then
      Pass3();
    else
      tmp8 := fputs(s, &out);
    end if;
  end loop;

  tmp8 := FCBClose(&in);
  tmp8 := FCBClose(&out);

  FCBDelete(&in);	#  remove("cowfix.$$$");
end if;

@asm "ld hl,0";		#mark NO ERRS
@asm "ld (80h),hl";

if fixed_push > 0 then print_i16(fixed_push as int16); print(" fixed PUSH statements\n"); end if;
if fixed_pop > 0 then print_i16(fixed_pop as int16); print(" fixed POP statements\n"); end if;
if fixed_jr > 0 then print_i16(fixed_jr as int16); print(" fixed JR statements\n"); end if;
if fixed_dword > 0 then print_i16(fixed_dword as int16); print(" fixed DWORD statements\n"); end if;
if long_db > 0 then print_i16(long_db as int16); print(" fixed too long DB statements\n"); end if;
if labels_dropped > 0 then print_i16(labels_dropped as int16); print(" not needed labels dropped\n"); end if;
if returns_added > 0 then print_i16(returns_added as int16); print(" RET statements added\n"); end if;
if jump_to_jump > 0 then print_i16(jump_to_jump as int16); print(" fixed JP to JP statements\n"); end if;
if statements_group > 0 then print_i16(statements_group as int16); print(" fixed statement groups involving conditionals\n"); end if;
if dropped_ld > 0 then print_i16(dropped_ld as int16); print(" dropped not needed LD statements\n"); end if;

print_nl();
print_i16(LineCounter as int16);
print(" input source lines processed\n");

print("DONE!\n");



